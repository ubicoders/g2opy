from __future__ import annotations
import numpy
import typing
from . import contrib
__all__ = ['AbstractOptimizationAlgorithmCreator', 'Affine', 'AffineCompact', 'AngleAxis', 'BaseBinaryEdge_1_double_VertexCam_VertexCam', 'BaseBinaryEdge_1_double_VertexSE2_VertexPointXY', 'BaseBinaryEdge_2_Vector2D_VertexPointXY_VertexPointXY', 'BaseBinaryEdge_2_Vector2D_VertexSBAPointXYZ_VertexCam', 'BaseBinaryEdge_2_Vector2D_VertexSBAPointXYZ_VertexSE3Expmap', 'BaseBinaryEdge_2_Vector2D_VertexSBAPointXYZ_VertexSim3Expmap', 'BaseBinaryEdge_2_Vector2D_VertexSE2_VertexPointXY', 'BaseBinaryEdge_3_EdgeGICP_VertexSE3_VertexSE3', 'BaseBinaryEdge_3_SE2_VertexSE2_VertexSE2', 'BaseBinaryEdge_3_Vector3D_VertexPointXYZ_VertexPointXYZ', 'BaseBinaryEdge_3_Vector3D_VertexSBAPointXYZ_VertexCam', 'BaseBinaryEdge_3_Vector3D_VertexSBAPointXYZ_VertexSCam', 'BaseBinaryEdge_3_Vector3D_VertexSBAPointXYZ_VertexSE3Expmap', 'BaseBinaryEdge_3_Vector3D_VertexSE3_VertexPointXYZ', 'BaseBinaryEdge_6_Isometry3D_VertexSE3_VertexSE3', 'BaseBinaryEdge_6_SE3Quat_VertexCam_VertexCam', 'BaseBinaryEdge_6_SE3Quat_VertexSE3Expmap_VertexSE3Expmap', 'BaseBinaryEdge_7_Sim3_VertexSim3Expmap_VertexSim3Expmap', 'BaseEdge_1_double', 'BaseEdge_2_Vector2D', 'BaseEdge_3_EdgeGICP', 'BaseEdge_3_SE2', 'BaseEdge_3_Vector3D', 'BaseEdge_3_VelocityMeasurement', 'BaseEdge_4_Vector4D', 'BaseEdge_6_Isometry3D', 'BaseEdge_6_SE3Quat', 'BaseEdge_7_Sim3', 'BaseMultiEdge_2_Vector2D', 'BaseMultiEdge_3_SE2', 'BaseMultiEdge_3_Vector3D', 'BaseMultiEdge_3_VelocityMeasurement', 'BaseMultiEdge_4_Vector4D', 'BaseMultiEdge_6_SE3Quat', 'BaseRobustKernel', 'BaseUnaryEdgeBaseUnaryEdge_2_Vector2D_VertexSE3Expmap', 'BaseUnaryEdgeBaseUnaryEdge_3_Vector3D_VertexSE3Expmap', 'BaseUnaryEdge_2_Vector2D_VertexSE2', 'BaseUnaryEdge_3_SE2_VertexSE2', 'BaseUnaryEdge_6_Isometry3D_VertexSE3', 'BaseVertex_1_double', 'BaseVertex_2_Vector2D', 'BaseVertex_3_SE2', 'BaseVertex_3_Vector3D', 'BaseVertex_4_Vector5d', 'BaseVertex_6_Isometry3D', 'BaseVertex_6_SBACam', 'BaseVertex_6_SE3Quat', 'BaseVertex_7_Sim3', 'BlockSolverBase', 'BlockSolverSE2', 'BlockSolverSE3', 'BlockSolverSim3', 'BlockSolverX', 'CameraParameters', 'DynamicBaseEdge_VectorXD', 'DynamicBaseMultiEdge_VectorXD', 'EdgeGICP', 'EdgeInverseSim3ProjectXYZ', 'EdgeNormal', 'EdgePointXY', 'EdgePointXYZ', 'EdgeProjectP2MC', 'EdgeProjectP2MCRight', 'EdgeProjectP2MC_Intrinsics', 'EdgeProjectP2SC', 'EdgeProjectPSI2UV', 'EdgeProjectXYZ2UV', 'EdgeProjectXYZ2UVU', 'EdgeSBACam', 'EdgeSBAScale', 'EdgeSE2', 'EdgeSE2LotsOfXY', 'EdgeSE2OdomDifferentialCalib', 'EdgeSE2Offset', 'EdgeSE2PointXY', 'EdgeSE2PointXYBearing', 'EdgeSE2PointXYCalib', 'EdgeSE2PointXYOffset', 'EdgeSE2Prior', 'EdgeSE2SensorCalib', 'EdgeSE2TwoPointsXY', 'EdgeSE2XYPrior', 'EdgeSE3', 'EdgeSE3Expmap', 'EdgeSE3LotsOfXYZ', 'EdgeSE3Offset', 'EdgeSE3PointXYZ', 'EdgeSE3PointXYZDepth', 'EdgeSE3PointXYZDisparity', 'EdgeSE3Prior', 'EdgeSE3ProjectXYZ', 'EdgeSE3ProjectXYZOnlyPose', 'EdgeSim3', 'EdgeSim3ProjectXYZ', 'EdgeStereoSE3ProjectXYZ', 'EdgeStereoSE3ProjectXYZOnlyPose', 'Edge_V_V_GICP', 'Edge_XYZ_VSC', 'EstimatePropagator', 'EstimatePropagatorCost', 'EstimatePropagatorCostOdometry', 'G2OBatchStatistics', 'HyperDijkstra', 'HyperGraph', 'HyperGraphAction', 'Isometry', 'Isometry2d', 'Isometry3d', 'JacobianWorkspace', 'LinearSolverCSparseSE2', 'LinearSolverCSparseSE3', 'LinearSolverCSparseSim3', 'LinearSolverCSparseX', 'LinearSolverCholmodSE2', 'LinearSolverCholmodSE3', 'LinearSolverCholmodSim3', 'LinearSolverCholmodX', 'LinearSolverDenseSE2', 'LinearSolverDenseSE3', 'LinearSolverDenseSim3', 'LinearSolverDenseX', 'LinearSolverEigenSE2', 'LinearSolverEigenSE3', 'LinearSolverEigenSim3', 'LinearSolverEigenX', 'LinearSolverPCGSE2', 'LinearSolverPCGSE3', 'LinearSolverPCGSim3', 'LinearSolverPCGX', 'MotionMeasurement', 'OdomConvert', 'OptimizableGraph', 'OptimizationAlgorithm', 'OptimizationAlgorithmDogleg', 'OptimizationAlgorithmGaussNewton', 'OptimizationAlgorithmLevenberg', 'OptimizationAlgorithmProperty', 'OptimizationAlgorithmWithHessian', 'Parameter', 'ParameterCamera', 'ParameterSE2Offset', 'ParameterSE3Offset', 'ParameterStereoCamera', 'Projective', 'PyBlockSolverBase', 'Quaternion', 'RegisterOptimizationAlgorithmProxy', 'RobustKernelCauchy', 'RobustKernelDCS', 'RobustKernelFair', 'RobustKernelGemanMcClure', 'RobustKernelHuber', 'RobustKernelPseudoHuber', 'RobustKernelSaturated', 'RobustKernelScaleDelta', 'RobustKernelTukey', 'RobustKernelWelsch', 'Rotation2d', 'SBACam', 'SE2', 'SE3Quat', 'Sim3', 'Solver', 'SparseBlockMatrixX', 'SparseOptimizer', 'SparseOptimizerTerminateAction', 'TransformTraits', 'UniformCostFunction', 'VelocityMeasurement', 'VertexCam', 'VertexIntrinsics', 'VertexOdomDifferentialParams', 'VertexPointXY', 'VertexPointXYZ', 'VertexSBAPointXYZ', 'VertexSCam', 'VertexSE2', 'VertexSE3', 'VertexSE3Expmap', 'VertexSim3Expmap', 'contrib']
class AbstractOptimizationAlgorithmCreator:
    pass
class AngleAxis:
    @staticmethod
    def ientity() -> AngleAxis:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: float, arg1: numpy.ndarray[float64[3, 1]]) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: AngleAxis) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: Quaternion) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: numpy.ndarray[float64[3, 3]]) -> None:
        ...
    @typing.overload
    def __mul__(self, arg0: AngleAxis) -> Quaternion:
        ...
    @typing.overload
    def __mul__(self, arg0: Quaternion) -> Quaternion:
        ...
    def __rmul__(self, arg0: Quaternion) -> Quaternion:
        ...
    def angle(self) -> float:
        ...
    def axis(self) -> numpy.ndarray[float64[3, 1]]:
        ...
    def from_rotation_matrix(self, arg0: numpy.ndarray[float64[3, 3]]) -> None:
        ...
    def inverse(self) -> AngleAxis:
        ...
    def matrix(self) -> numpy.ndarray[float64[3, 3]]:
        ...
    def rotation_matrix(self) -> numpy.ndarray[float64[3, 3]]:
        ...
    def to_rotation_matrix(self) -> numpy.ndarray[float64[3, 3]]:
        ...
    @property
    def R(self) -> numpy.ndarray[float64[3, 3]]:
        ...
class BaseBinaryEdge_1_double_VertexCam_VertexCam(BaseEdge_1_double):
    def all_vertices_fixed(self) -> bool:
        ...
    def construct_quadratic_form(self) -> None:
        ...
    def create_from(self) -> OptimizableGraph_Vertex:
        ...
    def create_to(self) -> OptimizableGraph_Vertex:
        ...
    def create_vertex(self, i: int) -> OptimizableGraph_Vertex:
        ...
    def jacobian_oplus_xi(self) -> numpy.ndarray[float64[1, 6], numpy.ndarray.flags.writeable]:
        ...
    def jacobian_oplus_xj(self) -> numpy.ndarray[float64[1, 6], numpy.ndarray.flags.writeable]:
        ...
    @typing.overload
    def linearize_oplus(self, arg0: JacobianWorkspace) -> None:
        ...
    @typing.overload
    def linearize_oplus(self) -> None:
        ...
    def map_hessian_memory(self, d: float, i: int, j: int, row_mayor: bool) -> None:
        ...
    def resize(self, arg0: int) -> None:
        ...
class BaseBinaryEdge_1_double_VertexSE2_VertexPointXY(BaseEdge_1_double):
    def all_vertices_fixed(self) -> bool:
        ...
    def construct_quadratic_form(self) -> None:
        ...
    def create_from(self) -> OptimizableGraph_Vertex:
        ...
    def create_to(self) -> OptimizableGraph_Vertex:
        ...
    def create_vertex(self, i: int) -> OptimizableGraph_Vertex:
        ...
    def jacobian_oplus_xi(self) -> numpy.ndarray[float64[1, 3], numpy.ndarray.flags.writeable]:
        ...
    def jacobian_oplus_xj(self) -> numpy.ndarray[float64[1, 2], numpy.ndarray.flags.writeable]:
        ...
    @typing.overload
    def linearize_oplus(self, arg0: JacobianWorkspace) -> None:
        ...
    @typing.overload
    def linearize_oplus(self) -> None:
        ...
    def map_hessian_memory(self, d: float, i: int, j: int, row_mayor: bool) -> None:
        ...
    def resize(self, arg0: int) -> None:
        ...
class BaseBinaryEdge_2_Vector2D_VertexPointXY_VertexPointXY(BaseEdge_2_Vector2D):
    def all_vertices_fixed(self) -> bool:
        ...
    def construct_quadratic_form(self) -> None:
        ...
    def create_from(self) -> OptimizableGraph_Vertex:
        ...
    def create_to(self) -> OptimizableGraph_Vertex:
        ...
    def create_vertex(self, i: int) -> OptimizableGraph_Vertex:
        ...
    def jacobian_oplus_xi(self) -> numpy.ndarray[float64[2, 2], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous]:
        ...
    def jacobian_oplus_xj(self) -> numpy.ndarray[float64[2, 2], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous]:
        ...
    @typing.overload
    def linearize_oplus(self, arg0: JacobianWorkspace) -> None:
        ...
    @typing.overload
    def linearize_oplus(self) -> None:
        ...
    def map_hessian_memory(self, d: float, i: int, j: int, row_mayor: bool) -> None:
        ...
    def resize(self, arg0: int) -> None:
        ...
class BaseBinaryEdge_2_Vector2D_VertexSBAPointXYZ_VertexCam(BaseEdge_2_Vector2D):
    def all_vertices_fixed(self) -> bool:
        ...
    def construct_quadratic_form(self) -> None:
        ...
    def create_from(self) -> OptimizableGraph_Vertex:
        ...
    def create_to(self) -> OptimizableGraph_Vertex:
        ...
    def create_vertex(self, i: int) -> OptimizableGraph_Vertex:
        ...
    def jacobian_oplus_xi(self) -> numpy.ndarray[float64[2, 3], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous]:
        ...
    def jacobian_oplus_xj(self) -> numpy.ndarray[float64[2, 6], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous]:
        ...
    @typing.overload
    def linearize_oplus(self, arg0: JacobianWorkspace) -> None:
        ...
    @typing.overload
    def linearize_oplus(self) -> None:
        ...
    def map_hessian_memory(self, d: float, i: int, j: int, row_mayor: bool) -> None:
        ...
    def resize(self, arg0: int) -> None:
        ...
class BaseBinaryEdge_2_Vector2D_VertexSBAPointXYZ_VertexSE3Expmap(BaseEdge_2_Vector2D):
    def all_vertices_fixed(self) -> bool:
        ...
    def construct_quadratic_form(self) -> None:
        ...
    def create_from(self) -> OptimizableGraph_Vertex:
        ...
    def create_to(self) -> OptimizableGraph_Vertex:
        ...
    def create_vertex(self, i: int) -> OptimizableGraph_Vertex:
        ...
    def jacobian_oplus_xi(self) -> numpy.ndarray[float64[2, 3], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous]:
        ...
    def jacobian_oplus_xj(self) -> numpy.ndarray[float64[2, 6], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous]:
        ...
    @typing.overload
    def linearize_oplus(self, arg0: JacobianWorkspace) -> None:
        ...
    @typing.overload
    def linearize_oplus(self) -> None:
        ...
    def map_hessian_memory(self, d: float, i: int, j: int, row_mayor: bool) -> None:
        ...
    def resize(self, arg0: int) -> None:
        ...
class BaseBinaryEdge_2_Vector2D_VertexSBAPointXYZ_VertexSim3Expmap(BaseEdge_2_Vector2D):
    def all_vertices_fixed(self) -> bool:
        ...
    def construct_quadratic_form(self) -> None:
        ...
    def create_from(self) -> OptimizableGraph_Vertex:
        ...
    def create_to(self) -> OptimizableGraph_Vertex:
        ...
    def create_vertex(self, i: int) -> OptimizableGraph_Vertex:
        ...
    def jacobian_oplus_xi(self) -> numpy.ndarray[float64[2, 3], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous]:
        ...
    def jacobian_oplus_xj(self) -> numpy.ndarray[float64[2, 7], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous]:
        ...
    @typing.overload
    def linearize_oplus(self, arg0: JacobianWorkspace) -> None:
        ...
    @typing.overload
    def linearize_oplus(self) -> None:
        ...
    def map_hessian_memory(self, d: float, i: int, j: int, row_mayor: bool) -> None:
        ...
    def resize(self, arg0: int) -> None:
        ...
class BaseBinaryEdge_2_Vector2D_VertexSE2_VertexPointXY(BaseEdge_2_Vector2D):
    def all_vertices_fixed(self) -> bool:
        ...
    def construct_quadratic_form(self) -> None:
        ...
    def create_from(self) -> OptimizableGraph_Vertex:
        ...
    def create_to(self) -> OptimizableGraph_Vertex:
        ...
    def create_vertex(self, i: int) -> OptimizableGraph_Vertex:
        ...
    def jacobian_oplus_xi(self) -> numpy.ndarray[float64[2, 3], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous]:
        ...
    def jacobian_oplus_xj(self) -> numpy.ndarray[float64[2, 2], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous]:
        ...
    @typing.overload
    def linearize_oplus(self, arg0: JacobianWorkspace) -> None:
        ...
    @typing.overload
    def linearize_oplus(self) -> None:
        ...
    def map_hessian_memory(self, d: float, i: int, j: int, row_mayor: bool) -> None:
        ...
    def resize(self, arg0: int) -> None:
        ...
class BaseBinaryEdge_3_EdgeGICP_VertexSE3_VertexSE3(BaseEdge_3_EdgeGICP):
    def all_vertices_fixed(self) -> bool:
        ...
    def construct_quadratic_form(self) -> None:
        ...
    def create_from(self) -> OptimizableGraph_Vertex:
        ...
    def create_to(self) -> OptimizableGraph_Vertex:
        ...
    def create_vertex(self, i: int) -> OptimizableGraph_Vertex:
        ...
    def jacobian_oplus_xi(self) -> numpy.ndarray[float64[3, 6], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous]:
        ...
    def jacobian_oplus_xj(self) -> numpy.ndarray[float64[3, 6], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous]:
        ...
    @typing.overload
    def linearize_oplus(self, arg0: JacobianWorkspace) -> None:
        ...
    @typing.overload
    def linearize_oplus(self) -> None:
        ...
    def map_hessian_memory(self, d: float, i: int, j: int, row_mayor: bool) -> None:
        ...
    def resize(self, arg0: int) -> None:
        ...
class BaseBinaryEdge_3_SE2_VertexSE2_VertexSE2(BaseEdge_3_SE2):
    def all_vertices_fixed(self) -> bool:
        ...
    def construct_quadratic_form(self) -> None:
        ...
    def create_from(self) -> OptimizableGraph_Vertex:
        ...
    def create_to(self) -> OptimizableGraph_Vertex:
        ...
    def create_vertex(self, i: int) -> OptimizableGraph_Vertex:
        ...
    def jacobian_oplus_xi(self) -> numpy.ndarray[float64[3, 3], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous]:
        ...
    def jacobian_oplus_xj(self) -> numpy.ndarray[float64[3, 3], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous]:
        ...
    @typing.overload
    def linearize_oplus(self, arg0: JacobianWorkspace) -> None:
        ...
    @typing.overload
    def linearize_oplus(self) -> None:
        ...
    def map_hessian_memory(self, d: float, i: int, j: int, row_mayor: bool) -> None:
        ...
    def resize(self, arg0: int) -> None:
        ...
class BaseBinaryEdge_3_Vector3D_VertexPointXYZ_VertexPointXYZ(BaseEdge_3_Vector3D):
    def all_vertices_fixed(self) -> bool:
        ...
    def construct_quadratic_form(self) -> None:
        ...
    def create_from(self) -> OptimizableGraph_Vertex:
        ...
    def create_to(self) -> OptimizableGraph_Vertex:
        ...
    def create_vertex(self, i: int) -> OptimizableGraph_Vertex:
        ...
    def jacobian_oplus_xi(self) -> numpy.ndarray[float64[3, 3], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous]:
        ...
    def jacobian_oplus_xj(self) -> numpy.ndarray[float64[3, 3], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous]:
        ...
    @typing.overload
    def linearize_oplus(self, arg0: JacobianWorkspace) -> None:
        ...
    @typing.overload
    def linearize_oplus(self) -> None:
        ...
    def map_hessian_memory(self, d: float, i: int, j: int, row_mayor: bool) -> None:
        ...
    def resize(self, arg0: int) -> None:
        ...
class BaseBinaryEdge_3_Vector3D_VertexSBAPointXYZ_VertexCam(BaseEdge_3_Vector3D):
    def all_vertices_fixed(self) -> bool:
        ...
    def construct_quadratic_form(self) -> None:
        ...
    def create_from(self) -> OptimizableGraph_Vertex:
        ...
    def create_to(self) -> OptimizableGraph_Vertex:
        ...
    def create_vertex(self, i: int) -> OptimizableGraph_Vertex:
        ...
    def jacobian_oplus_xi(self) -> numpy.ndarray[float64[3, 3], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous]:
        ...
    def jacobian_oplus_xj(self) -> numpy.ndarray[float64[3, 6], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous]:
        ...
    @typing.overload
    def linearize_oplus(self, arg0: JacobianWorkspace) -> None:
        ...
    @typing.overload
    def linearize_oplus(self) -> None:
        ...
    def map_hessian_memory(self, d: float, i: int, j: int, row_mayor: bool) -> None:
        ...
    def resize(self, arg0: int) -> None:
        ...
class BaseBinaryEdge_3_Vector3D_VertexSBAPointXYZ_VertexSCam(BaseEdge_3_Vector3D):
    def all_vertices_fixed(self) -> bool:
        ...
    def construct_quadratic_form(self) -> None:
        ...
    def create_from(self) -> OptimizableGraph_Vertex:
        ...
    def create_to(self) -> OptimizableGraph_Vertex:
        ...
    def create_vertex(self, i: int) -> OptimizableGraph_Vertex:
        ...
    def jacobian_oplus_xi(self) -> numpy.ndarray[float64[3, 3], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous]:
        ...
    def jacobian_oplus_xj(self) -> numpy.ndarray[float64[3, 6], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous]:
        ...
    @typing.overload
    def linearize_oplus(self, arg0: JacobianWorkspace) -> None:
        ...
    @typing.overload
    def linearize_oplus(self) -> None:
        ...
    def map_hessian_memory(self, d: float, i: int, j: int, row_mayor: bool) -> None:
        ...
    def resize(self, arg0: int) -> None:
        ...
class BaseBinaryEdge_3_Vector3D_VertexSBAPointXYZ_VertexSE3Expmap(BaseEdge_3_Vector3D):
    def all_vertices_fixed(self) -> bool:
        ...
    def construct_quadratic_form(self) -> None:
        ...
    def create_from(self) -> OptimizableGraph_Vertex:
        ...
    def create_to(self) -> OptimizableGraph_Vertex:
        ...
    def create_vertex(self, i: int) -> OptimizableGraph_Vertex:
        ...
    def jacobian_oplus_xi(self) -> numpy.ndarray[float64[3, 3], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous]:
        ...
    def jacobian_oplus_xj(self) -> numpy.ndarray[float64[3, 6], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous]:
        ...
    @typing.overload
    def linearize_oplus(self, arg0: JacobianWorkspace) -> None:
        ...
    @typing.overload
    def linearize_oplus(self) -> None:
        ...
    def map_hessian_memory(self, d: float, i: int, j: int, row_mayor: bool) -> None:
        ...
    def resize(self, arg0: int) -> None:
        ...
class BaseBinaryEdge_3_Vector3D_VertexSE3_VertexPointXYZ(BaseEdge_3_Vector3D):
    def all_vertices_fixed(self) -> bool:
        ...
    def construct_quadratic_form(self) -> None:
        ...
    def create_from(self) -> OptimizableGraph_Vertex:
        ...
    def create_to(self) -> OptimizableGraph_Vertex:
        ...
    def create_vertex(self, i: int) -> OptimizableGraph_Vertex:
        ...
    def jacobian_oplus_xi(self) -> numpy.ndarray[float64[3, 6], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous]:
        ...
    def jacobian_oplus_xj(self) -> numpy.ndarray[float64[3, 3], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous]:
        ...
    @typing.overload
    def linearize_oplus(self, arg0: JacobianWorkspace) -> None:
        ...
    @typing.overload
    def linearize_oplus(self) -> None:
        ...
    def map_hessian_memory(self, d: float, i: int, j: int, row_mayor: bool) -> None:
        ...
    def resize(self, arg0: int) -> None:
        ...
class BaseBinaryEdge_6_Isometry3D_VertexSE3_VertexSE3(BaseEdge_6_Isometry3D):
    def all_vertices_fixed(self) -> bool:
        ...
    def construct_quadratic_form(self) -> None:
        ...
    def create_from(self) -> OptimizableGraph_Vertex:
        ...
    def create_to(self) -> OptimizableGraph_Vertex:
        ...
    def create_vertex(self, i: int) -> OptimizableGraph_Vertex:
        ...
    def jacobian_oplus_xi(self) -> numpy.ndarray[float64[6, 6], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous]:
        ...
    def jacobian_oplus_xj(self) -> numpy.ndarray[float64[6, 6], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous]:
        ...
    @typing.overload
    def linearize_oplus(self, arg0: JacobianWorkspace) -> None:
        ...
    @typing.overload
    def linearize_oplus(self) -> None:
        ...
    def map_hessian_memory(self, d: float, i: int, j: int, row_mayor: bool) -> None:
        ...
    def resize(self, arg0: int) -> None:
        ...
class BaseBinaryEdge_6_SE3Quat_VertexCam_VertexCam(BaseEdge_6_SE3Quat):
    def all_vertices_fixed(self) -> bool:
        ...
    def construct_quadratic_form(self) -> None:
        ...
    def create_from(self) -> OptimizableGraph_Vertex:
        ...
    def create_to(self) -> OptimizableGraph_Vertex:
        ...
    def create_vertex(self, i: int) -> OptimizableGraph_Vertex:
        ...
    def jacobian_oplus_xi(self) -> numpy.ndarray[float64[6, 6], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous]:
        ...
    def jacobian_oplus_xj(self) -> numpy.ndarray[float64[6, 6], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous]:
        ...
    @typing.overload
    def linearize_oplus(self, arg0: JacobianWorkspace) -> None:
        ...
    @typing.overload
    def linearize_oplus(self) -> None:
        ...
    def map_hessian_memory(self, d: float, i: int, j: int, row_mayor: bool) -> None:
        ...
    def resize(self, arg0: int) -> None:
        ...
class BaseBinaryEdge_6_SE3Quat_VertexSE3Expmap_VertexSE3Expmap(BaseEdge_6_SE3Quat):
    def all_vertices_fixed(self) -> bool:
        ...
    def construct_quadratic_form(self) -> None:
        ...
    def create_from(self) -> OptimizableGraph_Vertex:
        ...
    def create_to(self) -> OptimizableGraph_Vertex:
        ...
    def create_vertex(self, i: int) -> OptimizableGraph_Vertex:
        ...
    def jacobian_oplus_xi(self) -> numpy.ndarray[float64[6, 6], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous]:
        ...
    def jacobian_oplus_xj(self) -> numpy.ndarray[float64[6, 6], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous]:
        ...
    @typing.overload
    def linearize_oplus(self, arg0: JacobianWorkspace) -> None:
        ...
    @typing.overload
    def linearize_oplus(self) -> None:
        ...
    def map_hessian_memory(self, d: float, i: int, j: int, row_mayor: bool) -> None:
        ...
    def resize(self, arg0: int) -> None:
        ...
class BaseBinaryEdge_7_Sim3_VertexSim3Expmap_VertexSim3Expmap(BaseEdge_7_Sim3):
    def all_vertices_fixed(self) -> bool:
        ...
    def construct_quadratic_form(self) -> None:
        ...
    def create_from(self) -> OptimizableGraph_Vertex:
        ...
    def create_to(self) -> OptimizableGraph_Vertex:
        ...
    def create_vertex(self, i: int) -> OptimizableGraph_Vertex:
        ...
    def jacobian_oplus_xi(self) -> numpy.ndarray[float64[7, 7], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous]:
        ...
    def jacobian_oplus_xj(self) -> numpy.ndarray[float64[7, 7], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous]:
        ...
    @typing.overload
    def linearize_oplus(self, arg0: JacobianWorkspace) -> None:
        ...
    @typing.overload
    def linearize_oplus(self) -> None:
        ...
    def map_hessian_memory(self, d: float, i: int, j: int, row_mayor: bool) -> None:
        ...
    def resize(self, arg0: int) -> None:
        ...
class BaseEdge_1_double(OptimizableGraph.OptimizableGraph_Edge):
    def chi2(self) -> float:
        ...
    def error(self) -> numpy.ndarray[float64[1, 1]]:
        ...
    def information(self) -> numpy.ndarray[float64[1, 1]]:
        ...
    def initial_estimate(self, arg0: set[Vertex], arg1: OptimizableGraph_Vertex) -> None:
        ...
    def measurement(self) -> float:
        ...
    def rank(self) -> int:
        ...
    def set_information(self, information: numpy.ndarray[float64[1, 1]]) -> None:
        ...
    def set_measurement(self, m: float) -> None:
        ...
class BaseEdge_2_Vector2D(OptimizableGraph.OptimizableGraph_Edge):
    def chi2(self) -> float:
        ...
    def error(self) -> numpy.ndarray[float64[2, 1]]:
        ...
    def information(self) -> numpy.ndarray[float64[2, 2]]:
        ...
    def initial_estimate(self, arg0: set[Vertex], arg1: OptimizableGraph_Vertex) -> None:
        ...
    def measurement(self) -> numpy.ndarray[float64[2, 1]]:
        ...
    def rank(self) -> int:
        ...
    def set_information(self, information: numpy.ndarray[float64[2, 2]]) -> None:
        ...
    def set_measurement(self, m: numpy.ndarray[float64[2, 1]]) -> None:
        ...
class BaseEdge_3_EdgeGICP(OptimizableGraph.OptimizableGraph_Edge):
    def chi2(self) -> float:
        ...
    def error(self) -> numpy.ndarray[float64[3, 1]]:
        ...
    def information(self) -> numpy.ndarray[float64[3, 3]]:
        ...
    def initial_estimate(self, arg0: set[Vertex], arg1: OptimizableGraph_Vertex) -> None:
        ...
    def measurement(self) -> EdgeGICP:
        ...
    def rank(self) -> int:
        ...
    def set_information(self, information: numpy.ndarray[float64[3, 3]]) -> None:
        ...
    def set_measurement(self, m: EdgeGICP) -> None:
        ...
class BaseEdge_3_SE2(OptimizableGraph.OptimizableGraph_Edge):
    def chi2(self) -> float:
        ...
    def error(self) -> numpy.ndarray[float64[3, 1]]:
        ...
    def information(self) -> numpy.ndarray[float64[3, 3]]:
        ...
    def initial_estimate(self, arg0: set[Vertex], arg1: OptimizableGraph_Vertex) -> None:
        ...
    def measurement(self) -> SE2:
        ...
    def rank(self) -> int:
        ...
    def set_information(self, information: numpy.ndarray[float64[3, 3]]) -> None:
        ...
    def set_measurement(self, m: SE2) -> None:
        ...
class BaseEdge_3_Vector3D(OptimizableGraph.OptimizableGraph_Edge):
    def chi2(self) -> float:
        ...
    def error(self) -> numpy.ndarray[float64[3, 1]]:
        ...
    def information(self) -> numpy.ndarray[float64[3, 3]]:
        ...
    def initial_estimate(self, arg0: set[Vertex], arg1: OptimizableGraph_Vertex) -> None:
        ...
    def measurement(self) -> numpy.ndarray[float64[3, 1]]:
        ...
    def rank(self) -> int:
        ...
    def set_information(self, information: numpy.ndarray[float64[3, 3]]) -> None:
        ...
    def set_measurement(self, m: numpy.ndarray[float64[3, 1]]) -> None:
        ...
class BaseEdge_3_VelocityMeasurement(OptimizableGraph.OptimizableGraph_Edge):
    def chi2(self) -> float:
        ...
    def error(self) -> numpy.ndarray[float64[3, 1]]:
        ...
    def information(self) -> numpy.ndarray[float64[3, 3]]:
        ...
    def initial_estimate(self, arg0: set[Vertex], arg1: OptimizableGraph_Vertex) -> None:
        ...
    def measurement(self) -> VelocityMeasurement:
        ...
    def rank(self) -> int:
        ...
    def set_information(self, information: numpy.ndarray[float64[3, 3]]) -> None:
        ...
    def set_measurement(self, m: VelocityMeasurement) -> None:
        ...
class BaseEdge_4_Vector4D(OptimizableGraph.OptimizableGraph_Edge):
    def chi2(self) -> float:
        ...
    def error(self) -> numpy.ndarray[float64[4, 1]]:
        ...
    def information(self) -> numpy.ndarray[float64[4, 4]]:
        ...
    def initial_estimate(self, arg0: set[Vertex], arg1: OptimizableGraph_Vertex) -> None:
        ...
    def measurement(self) -> numpy.ndarray[float64[4, 1]]:
        ...
    def rank(self) -> int:
        ...
    def set_information(self, information: numpy.ndarray[float64[4, 4]]) -> None:
        ...
    def set_measurement(self, m: numpy.ndarray[float64[4, 1]]) -> None:
        ...
class BaseEdge_6_Isometry3D(OptimizableGraph.OptimizableGraph_Edge):
    def chi2(self) -> float:
        ...
    def error(self) -> numpy.ndarray[float64[6, 1]]:
        ...
    def information(self) -> numpy.ndarray[float64[6, 6]]:
        ...
    def initial_estimate(self, arg0: set[Vertex], arg1: OptimizableGraph_Vertex) -> None:
        ...
    def measurement(self) -> Isometry3d:
        ...
    def rank(self) -> int:
        ...
    def set_information(self, information: numpy.ndarray[float64[6, 6]]) -> None:
        ...
    def set_measurement(self, m: Isometry3d) -> None:
        ...
class BaseEdge_6_SE3Quat(OptimizableGraph.OptimizableGraph_Edge):
    def chi2(self) -> float:
        ...
    def error(self) -> numpy.ndarray[float64[6, 1]]:
        ...
    def information(self) -> numpy.ndarray[float64[6, 6]]:
        ...
    def initial_estimate(self, arg0: set[Vertex], arg1: OptimizableGraph_Vertex) -> None:
        ...
    def measurement(self) -> SE3Quat:
        ...
    def rank(self) -> int:
        ...
    def set_information(self, information: numpy.ndarray[float64[6, 6]]) -> None:
        ...
    def set_measurement(self, m: SE3Quat) -> None:
        ...
class BaseEdge_7_Sim3(OptimizableGraph.OptimizableGraph_Edge):
    def chi2(self) -> float:
        ...
    def error(self) -> numpy.ndarray[float64[7, 1]]:
        ...
    def information(self) -> numpy.ndarray[float64[7, 7]]:
        ...
    def initial_estimate(self, arg0: set[Vertex], arg1: OptimizableGraph_Vertex) -> None:
        ...
    def measurement(self) -> Sim3:
        ...
    def rank(self) -> int:
        ...
    def set_information(self, information: numpy.ndarray[float64[7, 7]]) -> None:
        ...
    def set_measurement(self, m: Sim3) -> None:
        ...
class BaseMultiEdge_2_Vector2D(BaseEdge_2_Vector2D):
    def all_vertices_fixed(self) -> bool:
        ...
    def construct_quadratic_form(self) -> None:
        ...
    @typing.overload
    def linearize_oplus(self, arg0: JacobianWorkspace) -> None:
        ...
    @typing.overload
    def linearize_oplus(self) -> None:
        ...
    def mapHessianMemory(self, d: float, i: int, j: int, row_major: bool) -> None:
        ...
    def resize(self, size: int) -> None:
        ...
class BaseMultiEdge_3_SE2(BaseEdge_3_SE2):
    def all_vertices_fixed(self) -> bool:
        ...
    def construct_quadratic_form(self) -> None:
        ...
    @typing.overload
    def linearize_oplus(self, arg0: JacobianWorkspace) -> None:
        ...
    @typing.overload
    def linearize_oplus(self) -> None:
        ...
    def mapHessianMemory(self, d: float, i: int, j: int, row_major: bool) -> None:
        ...
    def resize(self, size: int) -> None:
        ...
class BaseMultiEdge_3_Vector3D(BaseEdge_3_Vector3D):
    def all_vertices_fixed(self) -> bool:
        ...
    def construct_quadratic_form(self) -> None:
        ...
    @typing.overload
    def linearize_oplus(self, arg0: JacobianWorkspace) -> None:
        ...
    @typing.overload
    def linearize_oplus(self) -> None:
        ...
    def mapHessianMemory(self, d: float, i: int, j: int, row_major: bool) -> None:
        ...
    def resize(self, size: int) -> None:
        ...
class BaseMultiEdge_3_VelocityMeasurement(BaseEdge_3_VelocityMeasurement):
    def all_vertices_fixed(self) -> bool:
        ...
    def construct_quadratic_form(self) -> None:
        ...
    @typing.overload
    def linearize_oplus(self, arg0: JacobianWorkspace) -> None:
        ...
    @typing.overload
    def linearize_oplus(self) -> None:
        ...
    def mapHessianMemory(self, d: float, i: int, j: int, row_major: bool) -> None:
        ...
    def resize(self, size: int) -> None:
        ...
class BaseMultiEdge_4_Vector4D(BaseEdge_4_Vector4D):
    def all_vertices_fixed(self) -> bool:
        ...
    def construct_quadratic_form(self) -> None:
        ...
    @typing.overload
    def linearize_oplus(self, arg0: JacobianWorkspace) -> None:
        ...
    @typing.overload
    def linearize_oplus(self) -> None:
        ...
    def mapHessianMemory(self, d: float, i: int, j: int, row_major: bool) -> None:
        ...
    def resize(self, size: int) -> None:
        ...
class BaseMultiEdge_6_SE3Quat(BaseEdge_6_SE3Quat):
    def all_vertices_fixed(self) -> bool:
        ...
    def construct_quadratic_form(self) -> None:
        ...
    @typing.overload
    def linearize_oplus(self, arg0: JacobianWorkspace) -> None:
        ...
    @typing.overload
    def linearize_oplus(self) -> None:
        ...
    def mapHessianMemory(self, d: float, i: int, j: int, row_major: bool) -> None:
        ...
    def resize(self, size: int) -> None:
        ...
class BaseRobustKernel:
    def delta(self) -> float:
        ...
    def robustify(self, squared_error: float, rho: numpy.ndarray[float64[3, 1]]) -> None:
        ...
    def set_delta(self, delta: float) -> None:
        ...
class BaseUnaryEdgeBaseUnaryEdge_2_Vector2D_VertexSE3Expmap(BaseEdge_2_Vector2D):
    def all_vertices_fixed(self) -> bool:
        ...
    def construct_quadratic_form(self) -> None:
        ...
    def create_vertex(self, i: int) -> OptimizableGraph_Vertex:
        ...
    def initial_estimate(self, arg0: set[Vertex], arg1: OptimizableGraph_Vertex) -> None:
        ...
    @typing.overload
    def linearize_oplus(self, arg0: JacobianWorkspace) -> None:
        ...
    @typing.overload
    def linearize_oplus(self) -> None:
        ...
    def resize(self, size: int) -> None:
        ...
class BaseUnaryEdgeBaseUnaryEdge_3_Vector3D_VertexSE3Expmap(BaseEdge_3_Vector3D):
    def all_vertices_fixed(self) -> bool:
        ...
    def construct_quadratic_form(self) -> None:
        ...
    def create_vertex(self, i: int) -> OptimizableGraph_Vertex:
        ...
    def initial_estimate(self, arg0: set[Vertex], arg1: OptimizableGraph_Vertex) -> None:
        ...
    @typing.overload
    def linearize_oplus(self, arg0: JacobianWorkspace) -> None:
        ...
    @typing.overload
    def linearize_oplus(self) -> None:
        ...
    def resize(self, size: int) -> None:
        ...
class BaseUnaryEdge_2_Vector2D_VertexSE2(BaseEdge_2_Vector2D):
    def all_vertices_fixed(self) -> bool:
        ...
    def construct_quadratic_form(self) -> None:
        ...
    def create_vertex(self, i: int) -> OptimizableGraph_Vertex:
        ...
    def initial_estimate(self, arg0: set[Vertex], arg1: OptimizableGraph_Vertex) -> None:
        ...
    @typing.overload
    def linearize_oplus(self, arg0: JacobianWorkspace) -> None:
        ...
    @typing.overload
    def linearize_oplus(self) -> None:
        ...
    def resize(self, size: int) -> None:
        ...
class BaseUnaryEdge_3_SE2_VertexSE2(BaseEdge_3_SE2):
    def all_vertices_fixed(self) -> bool:
        ...
    def construct_quadratic_form(self) -> None:
        ...
    def create_vertex(self, i: int) -> OptimizableGraph_Vertex:
        ...
    def initial_estimate(self, arg0: set[Vertex], arg1: OptimizableGraph_Vertex) -> None:
        ...
    @typing.overload
    def linearize_oplus(self, arg0: JacobianWorkspace) -> None:
        ...
    @typing.overload
    def linearize_oplus(self) -> None:
        ...
    def resize(self, size: int) -> None:
        ...
class BaseUnaryEdge_6_Isometry3D_VertexSE3(BaseEdge_6_Isometry3D):
    def all_vertices_fixed(self) -> bool:
        ...
    def construct_quadratic_form(self) -> None:
        ...
    def create_vertex(self, i: int) -> OptimizableGraph_Vertex:
        ...
    def initial_estimate(self, arg0: set[Vertex], arg1: OptimizableGraph_Vertex) -> None:
        ...
    @typing.overload
    def linearize_oplus(self, arg0: JacobianWorkspace) -> None:
        ...
    @typing.overload
    def linearize_oplus(self) -> None:
        ...
    def resize(self, size: int) -> None:
        ...
class BaseVertex_1_double(OptimizableGraph.OptimizableGraph_Vertex):
    @typing.overload
    def b(self, i: int) -> float:
        ...
    @typing.overload
    def b(self) -> numpy.ndarray[float64[1, 1]]:
        ...
    def clear_quadratic_form(self) -> None:
        ...
    def discard_top(self) -> None:
        ...
    def estimate(self) -> float:
        ...
    def hessian(self, i: int, j: int) -> float:
        ...
    def hessian_determinant(self) -> float:
        ...
    def pop(self) -> None:
        ...
    def push(self) -> None:
        ...
    def set_estimate(self, et: float) -> None:
        ...
    def solve_direct(self, arg0: float) -> float:
        ...
    def stack_size(self) -> int:
        ...
class BaseVertex_2_Vector2D(OptimizableGraph.OptimizableGraph_Vertex):
    @typing.overload
    def b(self, i: int) -> float:
        ...
    @typing.overload
    def b(self) -> numpy.ndarray[float64[2, 1]]:
        ...
    def clear_quadratic_form(self) -> None:
        ...
    def discard_top(self) -> None:
        ...
    def estimate(self) -> numpy.ndarray[float64[2, 1]]:
        ...
    def hessian(self, i: int, j: int) -> float:
        ...
    def hessian_determinant(self) -> float:
        ...
    def pop(self) -> None:
        ...
    def push(self) -> None:
        ...
    def set_estimate(self, et: numpy.ndarray[float64[2, 1]]) -> None:
        ...
    def solve_direct(self, arg0: float) -> float:
        ...
    def stack_size(self) -> int:
        ...
class BaseVertex_3_SE2(OptimizableGraph.OptimizableGraph_Vertex):
    @typing.overload
    def b(self, i: int) -> float:
        ...
    @typing.overload
    def b(self) -> numpy.ndarray[float64[3, 1]]:
        ...
    def clear_quadratic_form(self) -> None:
        ...
    def discard_top(self) -> None:
        ...
    def estimate(self) -> SE2:
        ...
    def hessian(self, i: int, j: int) -> float:
        ...
    def hessian_determinant(self) -> float:
        ...
    def pop(self) -> None:
        ...
    def push(self) -> None:
        ...
    def set_estimate(self, et: SE2) -> None:
        ...
    def solve_direct(self, arg0: float) -> float:
        ...
    def stack_size(self) -> int:
        ...
class BaseVertex_3_Vector3D(OptimizableGraph.OptimizableGraph_Vertex):
    @typing.overload
    def b(self, i: int) -> float:
        ...
    @typing.overload
    def b(self) -> numpy.ndarray[float64[3, 1]]:
        ...
    def clear_quadratic_form(self) -> None:
        ...
    def discard_top(self) -> None:
        ...
    def estimate(self) -> numpy.ndarray[float64[3, 1]]:
        ...
    def hessian(self, i: int, j: int) -> float:
        ...
    def hessian_determinant(self) -> float:
        ...
    def pop(self) -> None:
        ...
    def push(self) -> None:
        ...
    def set_estimate(self, et: numpy.ndarray[float64[3, 1]]) -> None:
        ...
    def solve_direct(self, arg0: float) -> float:
        ...
    def stack_size(self) -> int:
        ...
class BaseVertex_4_Vector5d(OptimizableGraph.OptimizableGraph_Vertex):
    @typing.overload
    def b(self, i: int) -> float:
        ...
    @typing.overload
    def b(self) -> numpy.ndarray[float64[4, 1]]:
        ...
    def clear_quadratic_form(self) -> None:
        ...
    def discard_top(self) -> None:
        ...
    def estimate(self) -> numpy.ndarray[float64[5, 1]]:
        ...
    def hessian(self, i: int, j: int) -> float:
        ...
    def hessian_determinant(self) -> float:
        ...
    def pop(self) -> None:
        ...
    def push(self) -> None:
        ...
    def set_estimate(self, et: numpy.ndarray[float64[5, 1]]) -> None:
        ...
    def solve_direct(self, arg0: float) -> float:
        ...
    def stack_size(self) -> int:
        ...
class BaseVertex_6_Isometry3D(OptimizableGraph.OptimizableGraph_Vertex):
    @typing.overload
    def b(self, i: int) -> float:
        ...
    @typing.overload
    def b(self) -> numpy.ndarray[float64[6, 1]]:
        ...
    def clear_quadratic_form(self) -> None:
        ...
    def discard_top(self) -> None:
        ...
    def estimate(self) -> Isometry3d:
        ...
    def hessian(self, i: int, j: int) -> float:
        ...
    def hessian_determinant(self) -> float:
        ...
    def pop(self) -> None:
        ...
    def push(self) -> None:
        ...
    def set_estimate(self, et: Isometry3d) -> None:
        ...
    def solve_direct(self, arg0: float) -> float:
        ...
    def stack_size(self) -> int:
        ...
class BaseVertex_6_SBACam(OptimizableGraph.OptimizableGraph_Vertex):
    @typing.overload
    def b(self, i: int) -> float:
        ...
    @typing.overload
    def b(self) -> numpy.ndarray[float64[6, 1]]:
        ...
    def clear_quadratic_form(self) -> None:
        ...
    def discard_top(self) -> None:
        ...
    def estimate(self) -> ...:
        ...
    def hessian(self, i: int, j: int) -> float:
        ...
    def hessian_determinant(self) -> float:
        ...
    def pop(self) -> None:
        ...
    def push(self) -> None:
        ...
    def set_estimate(self, et: ...) -> None:
        ...
    def solve_direct(self, arg0: float) -> float:
        ...
    def stack_size(self) -> int:
        ...
class BaseVertex_6_SE3Quat(OptimizableGraph.OptimizableGraph_Vertex):
    @typing.overload
    def b(self, i: int) -> float:
        ...
    @typing.overload
    def b(self) -> numpy.ndarray[float64[6, 1]]:
        ...
    def clear_quadratic_form(self) -> None:
        ...
    def discard_top(self) -> None:
        ...
    def estimate(self) -> SE3Quat:
        ...
    def hessian(self, i: int, j: int) -> float:
        ...
    def hessian_determinant(self) -> float:
        ...
    def pop(self) -> None:
        ...
    def push(self) -> None:
        ...
    def set_estimate(self, et: SE3Quat) -> None:
        ...
    def solve_direct(self, arg0: float) -> float:
        ...
    def stack_size(self) -> int:
        ...
class BaseVertex_7_Sim3(OptimizableGraph.OptimizableGraph_Vertex):
    @typing.overload
    def b(self, i: int) -> float:
        ...
    @typing.overload
    def b(self) -> numpy.ndarray[float64[7, 1]]:
        ...
    def clear_quadratic_form(self) -> None:
        ...
    def discard_top(self) -> None:
        ...
    def estimate(self) -> Sim3:
        ...
    def hessian(self, i: int, j: int) -> float:
        ...
    def hessian_determinant(self) -> float:
        ...
    def pop(self) -> None:
        ...
    def push(self) -> None:
        ...
    def set_estimate(self, et: Sim3) -> None:
        ...
    def solve_direct(self, arg0: float) -> float:
        ...
    def stack_size(self) -> int:
        ...
class BlockSolverBase(Solver):
    pass
class BlockSolverSE2(PyBlockSolverBase):
    @typing.overload
    def __init__(self, arg0: LinearSolverCholmodSE2) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: LinearSolverCSparseSE2) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: LinearSolverEigenSE2) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: LinearSolverDenseSE2) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: LinearSolverPCGSE2) -> None:
        ...
class BlockSolverSE3(PyBlockSolverBase):
    @typing.overload
    def __init__(self, arg0: LinearSolverCholmodSE3) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: LinearSolverCSparseSE3) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: LinearSolverEigenSE3) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: LinearSolverDenseSE3) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: LinearSolverPCGSE3) -> None:
        ...
class BlockSolverSim3(PyBlockSolverBase):
    @typing.overload
    def __init__(self, arg0: LinearSolverCholmodSim3) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: LinearSolverCSparseSim3) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: LinearSolverEigenSim3) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: LinearSolverDenseSim3) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: LinearSolverPCGSim3) -> None:
        ...
class BlockSolverX(PyBlockSolverBase):
    @typing.overload
    def __init__(self, arg0: LinearSolverCholmodX) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: LinearSolverCSparseX) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: LinearSolverEigenX) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: LinearSolverDenseX) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: LinearSolverPCGX) -> None:
        ...
class CameraParameters(Parameter):
    baseline: float
    focal_length: float
    principal_point: numpy.ndarray[float64[2, 1]]
    principle_point: numpy.ndarray[float64[2, 1]]
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, focal_length: float, principle_point: numpy.ndarray[float64[2, 1]], baseline: float) -> None:
        ...
    def cam_map(self, arg0: numpy.ndarray[float64[3, 1]]) -> numpy.ndarray[float64[2, 1]]:
        """
        trans_xyz
        """
    def stereocam_uvu_map(self, arg0: numpy.ndarray[float64[3, 1]]) -> numpy.ndarray[float64[3, 1]]:
        """
        trans_xyz
        """
class DynamicBaseEdge_VectorXD(OptimizableGraph.OptimizableGraph_Edge):
    def chi2(self) -> float:
        ...
    def error(self) -> numpy.ndarray[float64[m, 1]]:
        ...
    def information(self) -> numpy.ndarray[float64[m, n]]:
        ...
    def initial_estimate(self, arg0: set[Vertex], arg1: OptimizableGraph_Vertex) -> None:
        ...
    def measurement(self) -> numpy.ndarray[float64[m, 1]]:
        ...
    def rank(self) -> int:
        ...
    def set_information(self, information: numpy.ndarray[float64[m, n]]) -> None:
        ...
    def set_measurement(self, m: numpy.ndarray[float64[m, 1]]) -> None:
        ...
class DynamicBaseMultiEdge_VectorXD(DynamicBaseEdge_VectorXD):
    def all_vertices_fixed(self) -> bool:
        ...
    def construct_quadratic_form(self) -> None:
        ...
    @typing.overload
    def linearize_oplus(self, arg0: JacobianWorkspace) -> None:
        ...
    @typing.overload
    def linearize_oplus(self) -> None:
        ...
    def mapHessianMemory(self, d: float, i: int, j: int, row_major: bool) -> None:
        ...
    def resize(self, size: int) -> None:
        ...
class EdgeGICP:
    R0: numpy.ndarray[float64[3, 3]]
    R1: numpy.ndarray[float64[3, 3]]
    normal0: numpy.ndarray[float64[3, 1]]
    normal1: numpy.ndarray[float64[3, 1]]
    pos0: numpy.ndarray[float64[3, 1]]
    pos1: numpy.ndarray[float64[3, 1]]
    def __init__(self) -> None:
        ...
    def cov0(self, e: float) -> numpy.ndarray[float64[3, 3]]:
        """
        return a covariance matrix for plane-plane
        """
    def cov1(self, e: float) -> numpy.ndarray[float64[3, 3]]:
        """
        return a covariance matrix for plane-plane
        """
    def make_rot0(self) -> None:
        """
        set up rotation matrix for pos0
        """
    def make_rot1(self) -> None:
        """
        set up rotation matrix for pos1
        """
    def prec0(self, e: float) -> numpy.ndarray[float64[3, 3]]:
        """
        returns a precision matrix for point-plane
        """
    def prec1(self, e: float) -> numpy.ndarray[float64[3, 3]]:
        """
        returns a precision matrix for point-plane
        """
class EdgeInverseSim3ProjectXYZ(BaseBinaryEdge_2_Vector2D_VertexSBAPointXYZ_VertexSim3Expmap):
    def __init__(self) -> None:
        ...
    def compute_error(self) -> None:
        ...
class EdgeNormal:
    R: numpy.ndarray[float64[3, 3]]
    normal: numpy.ndarray[float64[3, 1]]
    pos: numpy.ndarray[float64[3, 1]]
    def __init__(self) -> None:
        ...
    def make_rot(self) -> None:
        ...
class EdgePointXY(BaseBinaryEdge_2_Vector2D_VertexPointXY_VertexPointXY):
    def __init__(self) -> None:
        ...
    def compute_error(self) -> None:
        ...
    def get_measurement_data(self, arg0: float) -> bool:
        ...
    def initial_estimate_possible(self, arg0: set[Vertex], arg1: OptimizableGraph_Vertex) -> float:
        ...
    def linearize_oplus(self) -> None:
        ...
    def measurement_dimension(self) -> int:
        ...
    def set_measurement(self, arg0: numpy.ndarray[float64[2, 1]]) -> None:
        ...
    def set_measurement_data(self, arg0: float) -> bool:
        ...
    def set_measurement_from_state(self) -> bool:
        ...
class EdgePointXYZ(BaseBinaryEdge_3_Vector3D_VertexPointXYZ_VertexPointXYZ):
    def __init__(self) -> None:
        ...
    def compute_error(self) -> None:
        ...
    def get_measurement_data(self, arg0: float) -> bool:
        ...
    def initial_estimate_possible(self, arg0: set[Vertex], arg1: OptimizableGraph_Vertex) -> float:
        ...
    def linearize_oplus(self) -> None:
        ...
    def measurement_dimension(self) -> int:
        ...
    def set_measurement(self, arg0: numpy.ndarray[float64[3, 1]]) -> None:
        ...
    def set_measurement_data(self, arg0: float) -> bool:
        ...
    def set_measurement_from_state(self) -> bool:
        ...
class EdgeProjectP2MC(BaseBinaryEdge_2_Vector2D_VertexSBAPointXYZ_VertexCam):
    def __init__(self) -> None:
        ...
    def compute_error(self) -> None:
        ...
    def linearize_oplus(self) -> None:
        ...
class EdgeProjectP2MCRight(BaseBinaryEdge_2_Vector2D_VertexSBAPointXYZ_VertexCam):
    def __init__(self) -> None:
        ...
    def compute_error(self) -> None:
        ...
    def linearize_oplus(self) -> None:
        ...
class EdgeProjectP2MC_Intrinsics(BaseMultiEdge_2_Vector2D):
    def __init__(self) -> None:
        ...
    def compute_error(self) -> None:
        ...
    def linearize_oplus(self) -> None:
        ...
class EdgeProjectP2SC(BaseBinaryEdge_3_Vector3D_VertexSBAPointXYZ_VertexCam):
    def __init__(self) -> None:
        ...
    def compute_error(self) -> None:
        ...
    def linearize_oplus(self) -> None:
        ...
class EdgeProjectPSI2UV(BaseMultiEdge_2_Vector2D):
    def __init__(self) -> None:
        ...
    def compute_error(self) -> None:
        ...
    def linearize_oplus(self) -> None:
        ...
class EdgeProjectXYZ2UV(BaseBinaryEdge_2_Vector2D_VertexSBAPointXYZ_VertexSE3Expmap):
    def __init__(self) -> None:
        ...
    def compute_error(self) -> None:
        ...
    def linearize_oplus(self) -> None:
        ...
class EdgeProjectXYZ2UVU(BaseBinaryEdge_3_Vector3D_VertexSBAPointXYZ_VertexSE3Expmap):
    def __init__(self) -> None:
        ...
    def compute_error(self) -> None:
        ...
class EdgeSBACam(BaseBinaryEdge_6_SE3Quat_VertexCam_VertexCam):
    def __init__(self) -> None:
        ...
    def compute_error(self) -> None:
        ...
    def get_measurement_data(self, arg0: float) -> bool:
        ...
    def initial_estimate_possible(self, arg0: set[Vertex], arg1: OptimizableGraph_Vertex) -> float:
        ...
    def measurement_dimension(self) -> int:
        ...
    def set_measurement(self, arg0: SE3Quat) -> None:
        ...
    def set_measurement_data(self, arg0: float) -> bool:
        ...
    def set_measurement_from_state(self) -> bool:
        ...
class EdgeSBAScale(BaseBinaryEdge_1_double_VertexCam_VertexCam):
    def __init__(self) -> None:
        ...
    def compute_error(self) -> None:
        ...
    def initial_estimate(self, arg0: set[Vertex], arg1: OptimizableGraph_Vertex) -> None:
        ...
    def initial_estimate_possible(self, arg0: set[Vertex], arg1: OptimizableGraph_Vertex) -> float:
        ...
    def set_measurement(self, arg0: float) -> None:
        ...
class EdgeSE2(BaseBinaryEdge_3_SE2_VertexSE2_VertexSE2):
    def __init__(self) -> None:
        ...
    def compute_error(self) -> None:
        ...
    def get_measurement_data(self, arg0: float) -> bool:
        ...
    def initial_estimate(self, arg0: set[Vertex], arg1: OptimizableGraph_Vertex) -> None:
        ...
    def initial_estimate_possible(self, arg0: set[Vertex], arg1: OptimizableGraph_Vertex) -> float:
        ...
    def linearize_oplus(self) -> None:
        ...
    def measurement_dimension(self) -> int:
        ...
    def set_measurement(self, arg0: SE2) -> None:
        ...
    def set_measurement_data(self, arg0: float) -> bool:
        ...
    def set_measurement_from_state(self) -> bool:
        ...
class EdgeSE2LotsOfXY(DynamicBaseMultiEdge_VectorXD):
    def __init__(self) -> None:
        ...
    def compute_error(self) -> None:
        ...
    def initial_estimate(self, arg0: set[Vertex], arg1: OptimizableGraph_Vertex) -> None:
        ...
    def initial_estimate_possible(self, arg0: set[Vertex], arg1: OptimizableGraph_Vertex) -> float:
        ...
    def linearize_oplus(self) -> None:
        ...
    def set_dimension(self, arg0: int) -> None:
        ...
    def set_measurement_from_state(self) -> bool:
        ...
    def set_size(self, arg0: int) -> None:
        ...
class EdgeSE2OdomDifferentialCalib(BaseMultiEdge_3_VelocityMeasurement):
    def __init__(self) -> None:
        ...
    def compute_error(self) -> None:
        ...
class EdgeSE2Offset(BaseBinaryEdge_3_SE2_VertexSE2_VertexSE2):
    def __init__(self) -> None:
        ...
    def compute_error(self) -> None:
        ...
    def get_measurement_data(self, arg0: float) -> bool:
        ...
    def initial_estimate(self, arg0: set[Vertex], arg1: OptimizableGraph_Vertex) -> None:
        ...
    def initial_estimate_possible(self, arg0: set[Vertex], arg1: OptimizableGraph_Vertex) -> float:
        ...
    def measurement_dimension(self) -> int:
        ...
    def set_measurement(self, arg0: SE2) -> None:
        ...
    def set_measurement_data(self, arg0: float) -> bool:
        ...
    def set_measurement_from_state(self) -> bool:
        ...
class EdgeSE2PointXY(BaseBinaryEdge_2_Vector2D_VertexSE2_VertexPointXY):
    def __init__(self) -> None:
        ...
    def compute_error(self) -> None:
        ...
    def get_measurement_data(self, arg0: float) -> bool:
        ...
    def initial_estimate(self, arg0: set[Vertex], arg1: OptimizableGraph_Vertex) -> None:
        ...
    def initial_estimate_possible(self, arg0: set[Vertex], arg1: OptimizableGraph_Vertex) -> float:
        ...
    def linearize_oplus(self) -> None:
        ...
    def measurement_dimension(self) -> int:
        ...
    def set_measurement_data(self, arg0: float) -> bool:
        ...
    def set_measurement_from_state(self) -> bool:
        ...
class EdgeSE2PointXYBearing(BaseBinaryEdge_1_double_VertexSE2_VertexPointXY):
    def __init__(self) -> None:
        ...
    def compute_error(self) -> None:
        ...
    def get_measurement_data(self, arg0: float) -> bool:
        ...
    def initial_estimate(self, arg0: set[Vertex], arg1: OptimizableGraph_Vertex) -> None:
        ...
    def initial_estimate_possible(self, arg0: set[Vertex], arg1: OptimizableGraph_Vertex) -> float:
        ...
    def measurement_dimension(self) -> int:
        ...
    def set_measurement_data(self, arg0: float) -> bool:
        ...
    def set_measurement_from_state(self) -> bool:
        ...
class EdgeSE2PointXYCalib(BaseMultiEdge_2_Vector2D):
    def __init__(self) -> None:
        ...
    def compute_error(self) -> None:
        ...
    def initial_estimate(self, arg0: set[Vertex], arg1: OptimizableGraph_Vertex) -> None:
        ...
    def initial_estimate_possible(self, arg0: set[Vertex], arg1: OptimizableGraph_Vertex) -> float:
        ...
class EdgeSE2PointXYOffset(BaseBinaryEdge_2_Vector2D_VertexSE2_VertexPointXY):
    def __init__(self) -> None:
        ...
    def compute_error(self) -> None:
        ...
    def get_measurement_data(self, arg0: float) -> bool:
        ...
    def initial_estimate(self, arg0: set[Vertex], arg1: OptimizableGraph_Vertex) -> None:
        ...
    def initial_estimate_possible(self, arg0: set[Vertex], arg1: OptimizableGraph_Vertex) -> float:
        ...
    def linearize_oplus(self) -> None:
        ...
    def measurement_dimension(self) -> int:
        ...
    def set_measurement(self, arg0: numpy.ndarray[float64[2, 1]]) -> None:
        ...
    def set_measurement_data(self, arg0: float) -> bool:
        ...
    def set_measurement_from_state(self) -> bool:
        ...
class EdgeSE2Prior(BaseUnaryEdge_3_SE2_VertexSE2):
    def __init__(self) -> None:
        ...
    def compute_error(self) -> None:
        ...
    def get_measurement_data(self, arg0: float) -> bool:
        ...
    def initial_estimate(self, arg0: set[Vertex], arg1: OptimizableGraph_Vertex) -> None:
        ...
    def initial_estimate_possible(self, arg0: set[Vertex], arg1: OptimizableGraph_Vertex) -> float:
        ...
    def measurement_dimension(self) -> int:
        ...
    def set_measurement(self, arg0: SE2) -> None:
        ...
    def set_measurement_data(self, arg0: float) -> bool:
        ...
class EdgeSE2SensorCalib(BaseMultiEdge_3_SE2):
    def __init__(self) -> None:
        ...
    def compute_error(self) -> None:
        ...
    def initial_estimate(self, arg0: set[Vertex], arg1: OptimizableGraph_Vertex) -> None:
        ...
    def initial_estimate_possible(self, arg0: set[Vertex], arg1: OptimizableGraph_Vertex) -> float:
        ...
    def set_measurement(self, arg0: SE2) -> None:
        ...
class EdgeSE2TwoPointsXY(BaseMultiEdge_4_Vector4D):
    def __init__(self) -> None:
        ...
    def compute_error(self) -> None:
        ...
    def initial_estimate(self, arg0: set[Vertex], arg1: OptimizableGraph_Vertex) -> None:
        ...
    def initial_estimate_possible(self, arg0: set[Vertex], arg1: OptimizableGraph_Vertex) -> float:
        ...
    def set_measurement_from_state(self) -> bool:
        ...
class EdgeSE2XYPrior(BaseUnaryEdge_2_Vector2D_VertexSE2):
    def __init__(self) -> None:
        ...
    def compute_error(self) -> None:
        ...
    def get_measurement_data(self, arg0: float) -> bool:
        ...
    def linearize_oplus(self) -> None:
        ...
    def measurement_dimension(self) -> int:
        ...
    def set_measurement_data(self, arg0: float) -> bool:
        ...
class EdgeSE3(BaseBinaryEdge_6_Isometry3D_VertexSE3_VertexSE3):
    def __init__(self) -> None:
        ...
    def compute_error(self) -> None:
        ...
    def get_measurement_data(self, arg0: float) -> bool:
        ...
    def initial_estimate(self, arg0: set[Vertex], arg1: OptimizableGraph_Vertex) -> None:
        ...
    def initial_estimate_possible(self, arg0: set[Vertex], arg1: OptimizableGraph_Vertex) -> float:
        ...
    def linearize_oplus(self) -> None:
        ...
    def measurement_dimension(self) -> int:
        ...
    def set_measurement(self, arg0: Isometry3d) -> None:
        ...
    def set_measurement_data(self, arg0: float) -> bool:
        ...
    def set_measurement_from_state(self) -> bool:
        ...
class EdgeSE3Expmap(BaseBinaryEdge_6_SE3Quat_VertexSE3Expmap_VertexSE3Expmap):
    def __init__(self) -> None:
        ...
    def compute_error(self) -> None:
        ...
    def linearize_oplus(self) -> None:
        ...
class EdgeSE3LotsOfXYZ(DynamicBaseMultiEdge_VectorXD):
    def __init__(self) -> None:
        ...
    def compute_error(self) -> None:
        ...
    def initial_estimate(self, arg0: set[Vertex], arg1: OptimizableGraph_Vertex) -> None:
        ...
    def initial_estimate_possible(self, arg0: set[Vertex], arg1: OptimizableGraph_Vertex) -> float:
        ...
    def linearize_oplus(self) -> None:
        ...
    def set_dimension(self, arg0: int) -> None:
        ...
    def set_measurement_from_state(self) -> bool:
        ...
    def set_size(self, arg0: int) -> None:
        ...
class EdgeSE3Offset(EdgeSE3):
    def __init__(self) -> None:
        ...
    def compute_error(self) -> None:
        ...
    def initial_estimate(self, arg0: set[Vertex], arg1: OptimizableGraph_Vertex) -> None:
        ...
    def initial_estimate_possible(self, arg0: set[Vertex], arg1: OptimizableGraph_Vertex) -> float:
        ...
    def linearize_oplus(self) -> None:
        ...
    def set_measurement_from_state(self) -> bool:
        ...
class EdgeSE3PointXYZ(BaseBinaryEdge_3_Vector3D_VertexSE3_VertexPointXYZ):
    def __init__(self) -> None:
        ...
    def compute_error(self) -> None:
        ...
    def get_measurement_data(self, arg0: float) -> bool:
        ...
    def initial_estimate(self, arg0: set[Vertex], arg1: OptimizableGraph_Vertex) -> None:
        ...
    def initial_estimate_possible(self, arg0: set[Vertex], arg1: OptimizableGraph_Vertex) -> float:
        ...
    def linearize_oplus(self) -> None:
        ...
    def measurement_dimension(self) -> int:
        ...
    def offset_parameter(self) -> ParameterSE3Offset:
        ...
    def set_measurement(self, arg0: numpy.ndarray[float64[3, 1]]) -> None:
        ...
    def set_measurement_data(self, arg0: float) -> bool:
        ...
    def set_measurement_from_state(self) -> bool:
        ...
class EdgeSE3PointXYZDepth(BaseBinaryEdge_3_Vector3D_VertexSE3_VertexPointXYZ):
    def __init__(self) -> None:
        ...
    def compute_error(self) -> None:
        ...
    def get_measurement_data(self, arg0: float) -> bool:
        ...
    def initial_estimate(self, arg0: set[Vertex], arg1: OptimizableGraph_Vertex) -> None:
        ...
    def initial_estimate_possible(self, arg0: set[Vertex], arg1: OptimizableGraph_Vertex) -> float:
        ...
    def linearize_oplus(self) -> None:
        ...
    def measurement_dimension(self) -> int:
        ...
    def set_measurement(self, arg0: numpy.ndarray[float64[3, 1]]) -> None:
        ...
    def set_measurement_data(self, arg0: float) -> bool:
        ...
    def set_measurement_from_state(self) -> bool:
        ...
class EdgeSE3PointXYZDisparity(BaseBinaryEdge_3_Vector3D_VertexSE3_VertexPointXYZ):
    def __init__(self) -> None:
        ...
    def camera_parameter(self) -> ParameterCamera:
        ...
    def compute_error(self) -> None:
        ...
    def get_measurement_data(self, arg0: float) -> bool:
        ...
    def initial_estimate(self, arg0: set[Vertex], arg1: OptimizableGraph_Vertex) -> None:
        ...
    def initial_estimate_possible(self, arg0: set[Vertex], arg1: OptimizableGraph_Vertex) -> float:
        ...
    def linearize_oplus(self) -> None:
        ...
    def measurement_dimension(self) -> int:
        ...
    def set_measurement(self, arg0: numpy.ndarray[float64[3, 1]]) -> None:
        ...
    def set_measurement_data(self, arg0: float) -> bool:
        ...
    def set_measurement_from_state(self) -> bool:
        ...
class EdgeSE3Prior(BaseUnaryEdge_6_Isometry3D_VertexSE3):
    def __init__(self) -> None:
        ...
    def compute_error(self) -> None:
        ...
    def get_measurement_data(self, arg0: float) -> bool:
        ...
    def initial_estimate(self, arg0: set[Vertex], arg1: OptimizableGraph_Vertex) -> None:
        ...
    def initial_estimate_possible(self, arg0: set[Vertex], arg1: OptimizableGraph_Vertex) -> float:
        ...
    def linearize_oplus(self) -> None:
        ...
    def measurement_dimension(self) -> int:
        ...
    def set_measurement(self, arg0: Isometry3d) -> None:
        ...
    def set_measurement_data(self, arg0: float) -> bool:
        ...
    def set_measurement_from_state(self) -> bool:
        ...
class EdgeSE3ProjectXYZ(BaseBinaryEdge_2_Vector2D_VertexSBAPointXYZ_VertexSE3Expmap):
    def __init__(self) -> None:
        ...
    def cam_project(self, arg0: numpy.ndarray[float64[3, 1]]) -> numpy.ndarray[float64[2, 1]]:
        ...
    def compute_error(self) -> None:
        ...
    def is_depth_positive(self) -> bool:
        ...
    def linearize_oplus(self) -> None:
        ...
class EdgeSE3ProjectXYZOnlyPose(BaseUnaryEdgeBaseUnaryEdge_2_Vector2D_VertexSE3Expmap):
    def __init__(self) -> None:
        ...
    def cam_project(self, arg0: numpy.ndarray[float64[3, 1]]) -> numpy.ndarray[float64[2, 1]]:
        ...
    def compute_error(self) -> None:
        ...
    def is_depth_positive(self) -> bool:
        ...
    def linearize_oplus(self) -> None:
        ...
class EdgeSim3(BaseBinaryEdge_7_Sim3_VertexSim3Expmap_VertexSim3Expmap):
    def __init__(self) -> None:
        ...
    def compute_error(self) -> None:
        ...
    def initial_estimate(self, arg0: set[Vertex], arg1: OptimizableGraph_Vertex) -> None:
        ...
    def initial_estimate_possible(self, arg0: set[Vertex], arg1: OptimizableGraph_Vertex) -> float:
        ...
class EdgeSim3ProjectXYZ(BaseBinaryEdge_2_Vector2D_VertexSBAPointXYZ_VertexSim3Expmap):
    def __init__(self) -> None:
        ...
    def compute_error(self) -> None:
        ...
class EdgeStereoSE3ProjectXYZ(BaseBinaryEdge_3_Vector3D_VertexSBAPointXYZ_VertexSE3Expmap):
    def __init__(self) -> None:
        ...
    def cam_project(self, arg0: numpy.ndarray[float64[3, 1]], arg1: float) -> numpy.ndarray[float64[3, 1]]:
        ...
    def compute_error(self) -> None:
        ...
    def is_depth_positive(self) -> bool:
        ...
    def linearize_oplus(self) -> None:
        ...
class EdgeStereoSE3ProjectXYZOnlyPose(BaseUnaryEdgeBaseUnaryEdge_3_Vector3D_VertexSE3Expmap):
    def __init__(self) -> None:
        ...
    def cam_project(self, arg0: numpy.ndarray[float64[3, 1]]) -> numpy.ndarray[float64[3, 1]]:
        ...
    def compute_error(self) -> None:
        ...
    def is_depth_positive(self) -> bool:
        ...
    def linearize_oplus(self) -> None:
        ...
class Edge_V_V_GICP(BaseBinaryEdge_3_EdgeGICP_VertexSE3_VertexSE3):
    dRidx: typing.ClassVar[numpy.ndarray]  # value = array([[ 0.,  0.,  0.],...
    dRidy: typing.ClassVar[numpy.ndarray]  # value = array([[ 0.,  0., -2.],...
    dRidz: typing.ClassVar[numpy.ndarray]  # value = array([[ 0.,  2.,  0.],...
    cov0: numpy.ndarray[float64[3, 3]]
    cov1: numpy.ndarray[float64[3, 3]]
    pl_pl: bool
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: Edge_V_V_GICP) -> None:
        ...
    def compute_error(self) -> None:
        ...
    def linearize_oplus(self) -> None:
        ...
class Edge_XYZ_VSC(BaseBinaryEdge_3_Vector3D_VertexSBAPointXYZ_VertexSCam):
    def __init__(self) -> None:
        ...
    def compute_error(self) -> None:
        ...
class EstimatePropagator:
    class EstimatePropagateAction:
        def __call__(self, arg0: OptimizableGraph_Edge, arg1: set[Vertex], arg2: OptimizableGraph_Vertex) -> None:
            ...
        def __init__(self) -> None:
            ...
    class EstimatePropagatorAdjacencyMapEntry:
        def __init__(self) -> None:
            ...
        def child(self) -> OptimizableGraph_Vertex:
            ...
        def distance(self) -> float:
            ...
        def edge(self) -> OptimizableGraph_Edge:
            ...
        def frontier_level(self) -> int:
            ...
        def parent(self) -> set[Vertex]:
            ...
        def reset(self) -> None:
            ...
    class EstimatePropagatorVertexIDHashFunction:
        def __call__(self, v: OptimizableGraph_Vertex) -> int:
            ...
    def __init__(self, g: OptimizableGraph) -> None:
        ...
    def adjacency_map(self) -> dict[OptimizableGraph_Vertex, EstimatePropagatorAdjacencyMapEntry]:
        ...
    def graph(self) -> OptimizableGraph:
        ...
    @typing.overload
    def propagate(self, v: OptimizableGraph_Vertex, cost: EstimatePropagatorCost, action: EstimatePropagateAction, maxDistance: float = 1.7976931348623157e+308, maxEdgeCost: float = 1.7976931348623157e+308) -> None:
        ...
    @typing.overload
    def propagate(self, vset: set[Vertex], cost: EstimatePropagatorCost, action: EstimatePropagateAction, maxDistance: float = 1.7976931348623157e+308, maxEdgeCost: float = 1.7976931348623157e+308) -> None:
        ...
    def visited(self) -> set[Vertex]:
        ...
class EstimatePropagatorCost:
    def __call__(self, edge: OptimizableGraph_Edge, from: set[Vertex], to: OptimizableGraph_Vertex) -> float:
        ...
    def __init__(self, graph: SparseOptimizer) -> None:
        ...
    def name(self) -> str:
        ...
class EstimatePropagatorCostOdometry(EstimatePropagatorCost):
    def __call__(self, edge: OptimizableGraph_Edge, from: set[Vertex], to: OptimizableGraph_Vertex) -> float:
        ...
    def __init__(self, graph: SparseOptimizer) -> None:
        ...
    def name(self) -> str:
        ...
class G2OBatchStatistics:
    chi2: float
    choleskyNNZ: int
    hessian_dimension: int
    hessian_landmark_dimension: int
    hessian_pose_dimension: int
    iteration: int
    iterations_linear_solver: int
    levenberg_iterations: int
    num_edges: int
    num_vertices: int
    time_iteration: float
    time_linear_solution: float
    time_linear_solver: float
    time_linearize: float
    time_marginals: float
    time_numeric_decomposition: float
    time_quadratic_form: float
    time_residuals: float
    time_schur_complement: float
    time_symbolic_decomposition: float
    time_update: float
    @staticmethod
    def global_stats() -> G2OBatchStatistics:
        ...
    @staticmethod
    def set_global_stats(arg0: G2OBatchStatistics) -> None:
        ...
    def __init__(self) -> None:
        ...
class HyperDijkstra:
    class HyperDijkstraAdjacencyMapEntry:
        def __init__(self, _child: Vertex = None, _parent: Vertex = None, _edge: Edge = None, _distance: float = 1.7976931348623157e+308) -> None:
            ...
        def child(self) -> Vertex:
            ...
        def children(self) -> set[Vertex]:
            ...
        def distance(self) -> float:
            ...
        def edge(self) -> Edge:
            ...
        def parent(self) -> Vertex:
            ...
    class HyperDijkstraCostFunction:
        pass
    class HyperDijkstraTreeAction:
        def __init__(self) -> None:
            ...
        @typing.overload
        def perform(self, v: Vertex, vParent: Vertex, e: Edge) -> float:
            ...
        @typing.overload
        def perform(self, v: Vertex, vParent: Vertex, e: Edge, distance: float) -> float:
            ...
    @staticmethod
    def compute_tree(amap: dict[Vertex, HyperDijkstraAdjacencyMapEntry]) -> None:
        ...
    @staticmethod
    def connected_subset(connected: set[Vertex], visited: set[Vertex], startingSet: set[Vertex], g: HyperGraph, v: Vertex, cost: HyperDijkstraCostFunction, distance: float, comparisonConditioner: float, maxEdgeCost: float = 1.7976931348623157e+308) -> None:
        ...
    @staticmethod
    def visit_adjacency_map(amap: dict[Vertex, HyperDijkstraAdjacencyMapEntry], action: HyperDijkstraTreeAction, useDistance: bool = False) -> None:
        ...
    def __init__(self, g: HyperGraph) -> None:
        ...
    def adjacency_map(self) -> dict[Vertex, HyperDijkstraAdjacencyMapEntry]:
        ...
    def graph(self) -> HyperGraph:
        ...
    @typing.overload
    def shortest_paths(self, v: Vertex, cost: HyperDijkstraCostFunction, maxDistance: float = 1.7976931348623157e+308, comparisonConditioner: float = 0.001, directed: bool = False, maxEdgeCost: float = 1.7976931348623157e+308) -> None:
        ...
    @typing.overload
    def shortest_paths(self, vset: set[Vertex], cost: HyperDijkstraCostFunction, maxDistance: float = 1.7976931348623157e+308, comparisonConditioner: float = 0.001, directed: bool = False, maxEdgeCost: float = 1.7976931348623157e+308) -> None:
        ...
    def visited(self) -> set[Vertex]:
        ...
class HyperGraph:
    class Data(HyperGraph.HyperGraphElement):
        def data_container(self) -> ...:
            ...
        def element_type(self) -> HyperGraphElementType:
            ...
        def next(self) -> Data:
            ...
        def set_data_container(self, data_container: ...) -> None:
            ...
        def set_next(self, next: Data) -> None:
            ...
    class DataContainer:
        def __init__(self) -> None:
            ...
        def add_user_data(self, obs: Data) -> None:
            ...
        def set_user_data(self, obs: Data) -> None:
            ...
        def user_data(self) -> Data:
            ...
    class Edge(HyperGraph.HyperGraphElement):
        def __init__(self, id: int = -2) -> None:
            ...
        def element_type(self) -> HyperGraphElementType:
            ...
        def id(self) -> int:
            ...
        def num_undefined_vertices(self) -> int:
            ...
        def resize(self, size: int) -> None:
            ...
        def set_id(self, id: int) -> None:
            ...
        def set_vertex(self, i: int, v: Vertex) -> None:
            ...
        def vertex(self, i: int) -> Vertex:
            ...
        def vertices(self) -> list[Vertex]:
            ...
    class HyperGraphElement:
        pass
    class HyperGraphElementType:
        HGET_CACHE: typing.ClassVar[HyperGraph.HyperGraphElementType]  # value = HyperGraphElementType.HGET_CACHE
        HGET_DATA: typing.ClassVar[HyperGraph.HyperGraphElementType]  # value = HyperGraphElementType.HGET_DATA
        HGET_EDGE: typing.ClassVar[HyperGraph.HyperGraphElementType]  # value = HyperGraphElementType.HGET_EDGE
        HGET_NUM_ELEMS: typing.ClassVar[HyperGraph.HyperGraphElementType]  # value = HyperGraphElementType.HGET_NUM_ELEMS
        HGET_PARAMETER: typing.ClassVar[HyperGraph.HyperGraphElementType]  # value = HyperGraphElementType.HGET_PARAMETER
        HGET_VERTEX: typing.ClassVar[HyperGraph.HyperGraphElementType]  # value = HyperGraphElementType.HGET_VERTEX
        __members__: typing.ClassVar[dict[str, HyperGraph.HyperGraphElementType]]  # value = {'HGET_VERTEX': HyperGraphElementType.HGET_VERTEX, 'HGET_EDGE': HyperGraphElementType.HGET_EDGE, 'HGET_PARAMETER': HyperGraphElementType.HGET_PARAMETER, 'HGET_CACHE': HyperGraphElementType.HGET_CACHE, 'HGET_DATA': HyperGraphElementType.HGET_DATA, 'HGET_NUM_ELEMS': HyperGraphElementType.HGET_NUM_ELEMS}
        @typing.overload
        def __eq__(self, arg0: HyperGraphElementType) -> bool:
            ...
        @typing.overload
        def __eq__(self, arg0: int) -> bool:
            ...
        def __getstate__(self) -> tuple:
            ...
        def __hash__(self) -> int:
            ...
        def __init__(self, arg0: int) -> None:
            ...
        def __int__(self) -> int:
            ...
        @typing.overload
        def __ne__(self, arg0: HyperGraphElementType) -> bool:
            ...
        @typing.overload
        def __ne__(self, arg0: int) -> bool:
            ...
        def __repr__(self) -> str:
            ...
        def __setstate__(self, arg0: tuple) -> None:
            ...
    class Vertex(HyperGraph.HyperGraphElement):
        def __init__(self, id: int = -1) -> None:
            ...
        def edges(self) -> set[...]:
            ...
        def element_type(self) -> HyperGraphElementType:
            ...
        def id(self) -> int:
            ...
        def set_id(self, id: int) -> None:
            ...
    HGET_CACHE: typing.ClassVar[HyperGraph.HyperGraphElementType]  # value = HyperGraphElementType.HGET_CACHE
    HGET_DATA: typing.ClassVar[HyperGraph.HyperGraphElementType]  # value = HyperGraphElementType.HGET_DATA
    HGET_EDGE: typing.ClassVar[HyperGraph.HyperGraphElementType]  # value = HyperGraphElementType.HGET_EDGE
    HGET_NUM_ELEMS: typing.ClassVar[HyperGraph.HyperGraphElementType]  # value = HyperGraphElementType.HGET_NUM_ELEMS
    HGET_PARAMETER: typing.ClassVar[HyperGraph.HyperGraphElementType]  # value = HyperGraphElementType.HGET_PARAMETER
    HGET_VERTEX: typing.ClassVar[HyperGraph.HyperGraphElementType]  # value = HyperGraphElementType.HGET_VERTEX
    def __init__(self) -> None:
        ...
    def add_edge(self, e: Edge) -> bool:
        ...
    def add_vertex(self, v: Vertex) -> bool:
        ...
    def change_id(self, v: Vertex, new_id: int) -> bool:
        ...
    def clear(self) -> None:
        ...
    def detach_vertex(self, v: Vertex) -> bool:
        ...
    def edges(self) -> set[Edge]:
        ...
    def merge_vertices(self, v_big: Vertex, v_small: Vertex, erase: bool) -> bool:
        ...
    def remove_edge(self, e: Edge) -> bool:
        ...
    def remove_vertex(self, v: Vertex, detach: bool) -> bool:
        ...
    def set_edge_vertex(self, e: Edge, pos: int, v: Vertex) -> bool:
        ...
    def vertex(self, id: int) -> Vertex:
        ...
    def vertices(self) -> dict[int, Vertex]:
        ...
class HyperGraphAction:
    pass
class Isometry2d:
    @staticmethod
    def identity() -> Isometry2d:
        ...
    def Quaternion(self) -> Quaternion:
        ...
    def __call__(self, arg0: int, arg1: int) -> float:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, other: Isometry2d) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: numpy.ndarray[float64[3, 3]]) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: numpy.ndarray[float64[2, 3]]) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: numpy.ndarray[float64[2, 2]], arg1: numpy.ndarray[float64[2, n]]) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: Quaternion, arg1: numpy.ndarray[float64[2, n]]) -> None:
        ...
    @typing.overload
    def __mul__(self, arg0: Isometry2d) -> Isometry2d:
        ...
    @typing.overload
    def __mul__(self, arg0: numpy.ndarray[float64[2, 1]]) -> numpy.ndarray[float64[2, 1]]:
        ...
    @typing.overload
    def __mul__(self, arg0: numpy.ndarray[float64[2, n]]) -> numpy.ndarray[float64[2, n]]:
        ...
    def cols(self) -> int:
        ...
    def inverse(self, traits: TransformTraits = ...) -> Isometry2d:
        ...
    def make_affine(self) -> None:
        ...
    def matrix(self) -> numpy.ndarray[float64[3, 3]]:
        ...
    def orientation(self) -> Quaternion:
        ...
    def position(self) -> numpy.ndarray[float64[2, 1]]:
        ...
    def rotation(self) -> Quaternion:
        ...
    def rotation_matrix(self) -> numpy.ndarray[float64[2, 2]]:
        ...
    def rows(self) -> int:
        ...
    def set_identity(self) -> None:
        ...
    @typing.overload
    def set_rotation(self, arg0: numpy.ndarray[float64[2, 2]]) -> None:
        ...
    @typing.overload
    def set_rotation(self, arg0: Quaternion) -> None:
        ...
    def set_translation(self, arg0: numpy.ndarray[float64[2, n]]) -> None:
        ...
    def translation(self) -> numpy.ndarray[float64[2, 1]]:
        ...
    @property
    def R(self) -> numpy.ndarray[float64[2, 2]]:
        ...
    @property
    def t(self) -> numpy.ndarray[float64[2, 1]]:
        ...
class Isometry3d:
    @staticmethod
    def identity() -> Isometry3d:
        ...
    def Quaternion(self) -> Quaternion:
        ...
    def __call__(self, arg0: int, arg1: int) -> float:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, other: Isometry3d) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: numpy.ndarray[float64[4, 4]]) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: numpy.ndarray[float64[3, 4]]) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: numpy.ndarray[float64[3, 3]], arg1: numpy.ndarray[float64[3, n]]) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: Quaternion, arg1: numpy.ndarray[float64[3, n]]) -> None:
        ...
    @typing.overload
    def __mul__(self, arg0: Isometry3d) -> Isometry3d:
        ...
    @typing.overload
    def __mul__(self, arg0: numpy.ndarray[float64[3, 1]]) -> numpy.ndarray[float64[3, 1]]:
        ...
    @typing.overload
    def __mul__(self, arg0: numpy.ndarray[float64[3, n]]) -> numpy.ndarray[float64[3, n]]:
        ...
    def cols(self) -> int:
        ...
    def inverse(self, traits: TransformTraits = ...) -> Isometry3d:
        ...
    def make_affine(self) -> None:
        ...
    def matrix(self) -> numpy.ndarray[float64[4, 4]]:
        ...
    def orientation(self) -> Quaternion:
        ...
    def position(self) -> numpy.ndarray[float64[3, 1]]:
        ...
    def rotation(self) -> Quaternion:
        ...
    def rotation_matrix(self) -> numpy.ndarray[float64[3, 3]]:
        ...
    def rows(self) -> int:
        ...
    def set_identity(self) -> None:
        ...
    @typing.overload
    def set_rotation(self, arg0: numpy.ndarray[float64[3, 3]]) -> None:
        ...
    @typing.overload
    def set_rotation(self, arg0: Quaternion) -> None:
        ...
    def set_translation(self, arg0: numpy.ndarray[float64[3, n]]) -> None:
        ...
    def translation(self) -> numpy.ndarray[float64[3, 1]]:
        ...
    @property
    def R(self) -> numpy.ndarray[float64[3, 3]]:
        ...
    @property
    def t(self) -> numpy.ndarray[float64[3, 1]]:
        ...
class JacobianWorkspace:
    def __init__(self) -> None:
        ...
    def allocate(self) -> bool:
        ...
    @typing.overload
    def update_size(self, e: Edge) -> None:
        ...
    @typing.overload
    def update_size(self, graph: OptimizableGraph) -> None:
        ...
    @typing.overload
    def update_size(self, num_vertices: int, dimension: int) -> None:
        ...
    def workspace_for_vertex(self, vertex_index: int) -> float:
        ...
class LinearSolverCSparseSE2:
    def __init__(self) -> None:
        ...
    def set_block_ordering(self, arg0: bool) -> None:
        ...
class LinearSolverCSparseSE3:
    def __init__(self) -> None:
        ...
    def set_block_ordering(self, arg0: bool) -> None:
        ...
class LinearSolverCSparseSim3:
    def __init__(self) -> None:
        ...
    def set_block_ordering(self, arg0: bool) -> None:
        ...
class LinearSolverCSparseX:
    def __init__(self) -> None:
        ...
    def set_block_ordering(self, arg0: bool) -> None:
        ...
class LinearSolverCholmodSE2:
    def __init__(self) -> None:
        ...
    def set_block_ordering(self, arg0: bool) -> None:
        ...
class LinearSolverCholmodSE3:
    def __init__(self) -> None:
        ...
    def set_block_ordering(self, arg0: bool) -> None:
        ...
class LinearSolverCholmodSim3:
    def __init__(self) -> None:
        ...
    def set_block_ordering(self, arg0: bool) -> None:
        ...
class LinearSolverCholmodX:
    def __init__(self) -> None:
        ...
    def set_block_ordering(self, arg0: bool) -> None:
        ...
class LinearSolverDenseSE2:
    def __init__(self) -> None:
        ...
class LinearSolverDenseSE3:
    def __init__(self) -> None:
        ...
class LinearSolverDenseSim3:
    def __init__(self) -> None:
        ...
class LinearSolverDenseX:
    def __init__(self) -> None:
        ...
class LinearSolverEigenSE2:
    def __init__(self) -> None:
        ...
    def set_block_ordering(self, arg0: bool) -> None:
        ...
class LinearSolverEigenSE3:
    def __init__(self) -> None:
        ...
    def set_block_ordering(self, arg0: bool) -> None:
        ...
class LinearSolverEigenSim3:
    def __init__(self) -> None:
        ...
    def set_block_ordering(self, arg0: bool) -> None:
        ...
class LinearSolverEigenX:
    def __init__(self) -> None:
        ...
    def set_block_ordering(self, arg0: bool) -> None:
        ...
class LinearSolverPCGSE2:
    def __init__(self) -> None:
        ...
class LinearSolverPCGSE3:
    def __init__(self) -> None:
        ...
class LinearSolverPCGSim3:
    def __init__(self) -> None:
        ...
class LinearSolverPCGX:
    def __init__(self) -> None:
        ...
class MotionMeasurement:
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, x: float, y: float, theta: float, dt: float) -> None:
        ...
    @typing.overload
    def __init__(self, m: numpy.ndarray[float64[3, 1]], dt: float) -> None:
        ...
    def dt(self) -> float:
        ...
    def measurement(self) -> numpy.ndarray[float64[3, 1]]:
        ...
    def set_dt(self, arg0: float) -> None:
        ...
    def set_theta(self, arg0: float) -> None:
        ...
    def set_x(self, arg0: float) -> None:
        ...
    def set_y(self, arg0: float) -> None:
        ...
    def theta(self) -> float:
        ...
    def x(self) -> float:
        ...
    def y(self) -> float:
        ...
class OdomConvert:
    @staticmethod
    def convert_to_motion(arg0: VelocityMeasurement, arg1: float) -> MotionMeasurement:
        ...
    @staticmethod
    def convert_to_velocity(arg0: MotionMeasurement) -> VelocityMeasurement:
        ...
    @staticmethod
    def to_motion(arg0: VelocityMeasurement, arg1: float) -> MotionMeasurement:
        ...
    @staticmethod
    def to_velocity(arg0: MotionMeasurement) -> VelocityMeasurement:
        ...
class OptimizableGraph(HyperGraph):
    class ActionType:
        AT_NUM_ELEMENTS: typing.ClassVar[OptimizableGraph.ActionType]  # value = ActionType.AT_NUM_ELEMENTS
        AT_PREITERATION: typing.ClassVar[OptimizableGraph.ActionType]  # value = ActionType.AT_PREITERATION
        __members__: typing.ClassVar[dict[str, OptimizableGraph.ActionType]]  # value = {'AT_PREITERATION': ActionType.AT_PREITERATION, 'AT_NUM_ELEMENTS': ActionType.AT_NUM_ELEMENTS}
        @typing.overload
        def __eq__(self, arg0: ActionType) -> bool:
            ...
        @typing.overload
        def __eq__(self, arg0: int) -> bool:
            ...
        def __getstate__(self) -> tuple:
            ...
        def __hash__(self) -> int:
            ...
        def __init__(self, arg0: int) -> None:
            ...
        def __int__(self) -> int:
            ...
        @typing.overload
        def __ne__(self, arg0: ActionType) -> bool:
            ...
        @typing.overload
        def __ne__(self, arg0: int) -> bool:
            ...
        def __repr__(self) -> str:
            ...
        def __setstate__(self, arg0: tuple) -> None:
            ...
    class EdgeIDCompare:
        def __call__(self: ..., arg0: ...) -> bool:
            ...
    class OptimizableGraph_Edge(HyperGraph.Edge, HyperGraph.DataContainer):
        def clone(self) -> OptimizableGraph_Edge:
            ...
        def create_vertex(self, arg0: int) -> OptimizableGraph_Vertex:
            ...
        def dimension(self) -> int:
            ...
        def get_measurement_data(self, m: float) -> bool:
            ...
        def graph(self) -> OptimizableGraph:
            ...
        def initial_estimate_possible(self, from: set[Vertex], to: OptimizableGraph_Vertex) -> float:
            ...
        def internal_id(self) -> int:
            ...
        def level(self) -> int:
            ...
        def measurement_dimension(self) -> int:
            ...
        def num_parameters(self) -> int:
            ...
        def parameter(self, arg0: int) -> ...:
            ...
        def resize_parameters(self, arg0: int) -> None:
            ...
        def robust_kernel(self) -> ...:
            ...
        def set_level(self, l: int) -> None:
            ...
        def set_measurement_data(self, m: float) -> bool:
            ...
        def set_measurement_from_state(self) -> bool:
            ...
        def set_parameter_id(self, arg_num: int, param_id: int) -> bool:
            ...
        def set_robust_kernel(self, ptr: ...) -> None:
            ...
    class OptimizableGraph_Vertex(HyperGraph.Vertex, HyperGraph.DataContainer):
        def clone(self) -> OptimizableGraph_Vertex:
            ...
        def col_in_hessian(self) -> int:
            ...
        def dimension(self) -> int:
            ...
        def estimate_dimension(self) -> int:
            ...
        def fixed(self) -> bool:
            ...
        @typing.overload
        def get_estimate_data(self, estimate: float) -> bool:
            ...
        @typing.overload
        def get_estimate_data(self, estimate: list[float]) -> bool:
            ...
        @typing.overload
        def get_minimal_estimate_data(self, estimate: float) -> bool:
            ...
        @typing.overload
        def get_minimal_estimate_data(self, estimate: list[float]) -> bool:
            ...
        def graph(self) -> OptimizableGraph:
            ...
        def hessian_index(self) -> int:
            ...
        def lock_quadratic_form(self) -> None:
            ...
        def marginalized(self) -> bool:
            ...
        def minimal_estimate_dimension(self) -> int:
            ...
        def oplus(self, v: float) -> None:
            ...
        def set_col_in_hessian(self, c: int) -> None:
            ...
        @typing.overload
        def set_estimate_data(self, estimate: float) -> bool:
            ...
        @typing.overload
        def set_estimate_data(self, estimate: list[float]) -> bool:
            ...
        def set_fixed(self, fixed: bool) -> None:
            ...
        def set_hessian_index(self, ti: int) -> None:
            ...
        def set_id(self, id: int) -> None:
            ...
        def set_marginalized(self, marginalized: bool) -> None:
            ...
        @typing.overload
        def set_minimal_estimate_data(self, estimate: float) -> bool:
            ...
        @typing.overload
        def set_minimal_estimate_data(self, estimate: list[float]) -> bool:
            ...
        def set_to_origin(self) -> None:
            ...
        def unlock_quadratic_form(self) -> None:
            ...
        def update_cache(self) -> None:
            ...
    class VertexIDCompare:
        def __call__(self: ..., arg0: ...) -> bool:
            ...
    AT_NUM_ELEMENTS: typing.ClassVar[OptimizableGraph.ActionType]  # value = ActionType.AT_NUM_ELEMENTS
    AT_PREITERATION: typing.ClassVar[OptimizableGraph.ActionType]  # value = ActionType.AT_PREITERATION
    @staticmethod
    def init_multi_threading() -> bool:
        ...
    def __init__(self) -> None:
        ...
    @typing.overload
    def add_edge(self, e: OptimizableGraph_Edge) -> bool:
        ...
    @typing.overload
    def add_edge(self, e: Edge) -> bool:
        ...
    def add_graph(self, g: OptimizableGraph) -> None:
        ...
    def add_parameter(self, p: ...) -> bool:
        ...
    def add_post_iteration_action(self, action: ...) -> bool:
        ...
    def add_pre_iteration_action(self, action: ...) -> bool:
        ...
    @typing.overload
    def add_vertex(self, v: OptimizableGraph_Vertex, user_data: Data) -> bool:
        ...
    @typing.overload
    def add_vertex(self, v: OptimizableGraph_Vertex) -> bool:
        ...
    @typing.overload
    def add_vertex(self, v: Vertex, user_data: Data) -> bool:
        ...
    @typing.overload
    def add_vertex(self, v: Vertex) -> bool:
        ...
    def chi2(self) -> float:
        ...
    def clear_parameters(self) -> None:
        ...
    def dimensions(self) -> set[int]:
        ...
    @typing.overload
    def discard_top(self) -> None:
        ...
    @typing.overload
    def discard_top(self, arg0: set[Vertex]) -> None:
        ...
    def jacobian_workspace(self) -> ...:
        ...
    def load(self, filename: str, create_edges: bool = True) -> bool:
        ...
    def max_dimension(self) -> int:
        ...
    def optimize(self, iterations: int, online: bool = False) -> int:
        ...
    def parameter(self, id: int) -> ...:
        ...
    @typing.overload
    def pop(self) -> None:
        ...
    @typing.overload
    def pop(self, arg0: set[Vertex]) -> None:
        ...
    def post_iteration(self, arg0: int) -> None:
        ...
    def pre_iteration(self, arg0: int) -> None:
        ...
    @typing.overload
    def push(self) -> None:
        ...
    @typing.overload
    def push(self, arg0: set[Vertex]) -> None:
        ...
    def remove_post_iteration_action(self, action: ...) -> bool:
        ...
    def remove_pre_iteration_action(self, action: ...) -> bool:
        ...
    def save(self, filename: str, level: int = 0) -> bool:
        ...
    def set_edge_vertex(self, e: Edge, pos: int, v: Vertex) -> bool:
        ...
    def set_fixed(self, vset: set[Vertex], fixes: bool) -> None:
        ...
    def verify_information_matrices(self, verbose: bool = False) -> bool:
        ...
    def vertex(self, id: int) -> OptimizableGraph_Vertex:
        ...
class OptimizationAlgorithm:
    pass
class OptimizationAlgorithmDogleg(OptimizationAlgorithmWithHessian):
    def __init__(self, arg0: PyBlockSolverBase) -> None:
        ...
class OptimizationAlgorithmGaussNewton(OptimizationAlgorithmWithHessian):
    def __init__(self, arg0: PyBlockSolverBase) -> None:
        ...
class OptimizationAlgorithmLevenberg(OptimizationAlgorithmWithHessian):
    def __init__(self, arg0: PyBlockSolverBase) -> None:
        ...
class OptimizationAlgorithmProperty:
    pass
class OptimizationAlgorithmWithHessian(OptimizationAlgorithm):
    pass
class Parameter(HyperGraph.HyperGraphElement):
    def element_type(self) -> HyperGraphElementType:
        ...
    def id(self) -> int:
        ...
    def set_id(self, id: int) -> None:
        ...
class ParameterCamera(ParameterSE3Offset):
    def Kcam(self) -> numpy.ndarray[float64[3, 3]]:
        ...
    def Kcam_inverseOffsetR(self) -> numpy.ndarray[float64[3, 3]]:
        ...
    def __init__(self) -> None:
        ...
    def invKcam(self) -> numpy.ndarray[float64[3, 3]]:
        ...
    def setKcam(self, arg0: float, arg1: float, arg2: float, arg3: float) -> None:
        ...
    def setOffset(self, arg0: Isometry3d) -> None:
        ...
class ParameterSE2Offset(Parameter):
    def __init__(self) -> None:
        ...
    def inverse_offset_matrix(self) -> Isometry2d:
        ...
    def offset(self) -> ...:
        ...
    def offset_matrix(self) -> Isometry2d:
        ...
    def set_offset(self, arg0: ...) -> None:
        ...
class ParameterSE3Offset(Parameter):
    def __init__(self) -> None:
        ...
    def inverse_offset(self) -> Isometry3d:
        ...
    def offset(self) -> Isometry3d:
        ...
    def set_offset(self, arg0: Isometry3d) -> None:
        ...
class ParameterStereoCamera(ParameterCamera):
    def __init__(self) -> None:
        ...
    def baseline(self) -> float:
        ...
    def set_baseline(self, arg0: float) -> None:
        ...
class PyBlockSolverBase:
    pass
class Quaternion:
    @staticmethod
    def from_two_vectors(arg0: numpy.ndarray[float64[3, 1]], arg1: numpy.ndarray[float64[3, 1]]) -> Quaternion:
        ...
    @staticmethod
    def identity() -> Quaternion:
        ...
    def __imul__(self, arg0: Quaternion) -> Quaternion:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: Quaternion) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: ...) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: numpy.ndarray[float64[3, 3]]) -> None:
        ...
    @typing.overload
    def __init__(self, w: float, x: float, y: float, z: float) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: numpy.ndarray[float64[4, 1]]) -> None:
        ...
    @typing.overload
    def __mul__(self, arg0: Quaternion) -> Quaternion:
        ...
    @typing.overload
    def __mul__(self, arg0: numpy.ndarray[float64[3, 1]]) -> numpy.ndarray[float64[3, 1]]:
        ...
    def angular_distance(self, arg0: Quaternion) -> float:
        ...
    def coeffs(self) -> numpy.ndarray[float64[4, 1]]:
        ...
    def conjugate(self) -> Quaternion:
        ...
    def dot(self, arg0: Quaternion) -> float:
        ...
    def inverse(self) -> Quaternion:
        ...
    def matrix(self) -> numpy.ndarray[float64[3, 3]]:
        ...
    def norm(self) -> float:
        ...
    def normalize(self) -> None:
        ...
    def normalized(self) -> Quaternion:
        ...
    def rotation_matrix(self) -> numpy.ndarray[float64[3, 3]]:
        ...
    def set_identity(self) -> None:
        ...
    def squared_norm(self) -> float:
        ...
    def vec(self) -> numpy.ndarray[float64[3, 1]]:
        ...
    def w(self) -> float:
        ...
    def x(self) -> float:
        ...
    def y(self) -> float:
        ...
    def z(self) -> float:
        ...
    @property
    def R(self) -> numpy.ndarray[float64[3, 3]]:
        ...
class RegisterOptimizationAlgorithmProxy:
    pass
class RobustKernelCauchy(BaseRobustKernel):
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, delta: float) -> None:
        ...
    def robustify(self, e2: float, rho: numpy.ndarray[float64[3, 1]]) -> None:
        ...
class RobustKernelDCS(BaseRobustKernel):
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, delta: float) -> None:
        ...
    def robustify(self, e2: float, rho: numpy.ndarray[float64[3, 1]]) -> None:
        ...
class RobustKernelFair(BaseRobustKernel):
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, delta: float) -> None:
        ...
    def robustify(self, e2: float, rho: numpy.ndarray[float64[3, 1]]) -> None:
        ...
class RobustKernelGemanMcClure(BaseRobustKernel):
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, delta: float) -> None:
        ...
    def robustify(self, e2: float, rho: numpy.ndarray[float64[3, 1]]) -> None:
        ...
class RobustKernelHuber(BaseRobustKernel):
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, delta: float) -> None:
        ...
    def robustify(self, e2: float, rho: numpy.ndarray[float64[3, 1]]) -> None:
        ...
class RobustKernelPseudoHuber(BaseRobustKernel):
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, delta: float) -> None:
        ...
    def robustify(self, e2: float, rho: numpy.ndarray[float64[3, 1]]) -> None:
        ...
class RobustKernelSaturated(BaseRobustKernel):
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, delta: float) -> None:
        ...
    def robustify(self, e2: float, rho: numpy.ndarray[float64[3, 1]]) -> None:
        ...
class RobustKernelScaleDelta(BaseRobustKernel):
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, delta: float = 1.0) -> None:
        ...
    @typing.overload
    def __init__(self, kernel: BaseRobustKernel, delta: float = 1.0) -> None:
        ...
    @typing.overload
    def __init__(self, delta: float) -> None:
        ...
    def kernel(self) -> BaseRobustKernel:
        ...
    def robustify(self, error: float, rho: numpy.ndarray[float64[3, 1]]) -> None:
        ...
    def set_kernel(self, ptr: BaseRobustKernel) -> None:
        ...
class RobustKernelTukey(BaseRobustKernel):
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, delta: float) -> None:
        ...
    def robustify(self, e2: float, rho: numpy.ndarray[float64[3, 1]]) -> None:
        ...
class RobustKernelWelsch(BaseRobustKernel):
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, delta: float) -> None:
        ...
    def robustify(self, e2: float, rho: numpy.ndarray[float64[3, 1]]) -> None:
        ...
class Rotation2d:
    @staticmethod
    def ientity() -> Rotation2d:
        ...
    def __imul__(self, arg0: Rotation2d) -> Rotation2d:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: Rotation2d) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: float) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: numpy.ndarray[float64[2, 2]]) -> None:
        ...
    @typing.overload
    def __mul__(self, arg0: Rotation2d) -> Rotation2d:
        ...
    @typing.overload
    def __mul__(self, arg0: numpy.ndarray[float64[2, 1]]) -> numpy.ndarray[float64[2, 1]]:
        ...
    def angle(self) -> float:
        ...
    def from_rotation_matrix(self, arg0: numpy.ndarray[float64[2, 2]]) -> None:
        ...
    def inverse(self) -> Rotation2d:
        ...
    def matrix(self) -> numpy.ndarray[float64[2, 2]]:
        ...
    def rotation_matrix(self) -> numpy.ndarray[float64[2, 2]]:
        ...
    def slerp(self, arg0: float, arg1: Rotation2d) -> Rotation2d:
        ...
    def smallest_angle(self) -> float:
        ...
    def smallest_positive_angle(self) -> float:
        ...
    def to_rotation_matrix(self) -> numpy.ndarray[float64[2, 2]]:
        ...
    @property
    def R(self) -> numpy.ndarray[float64[2, 2]]:
        ...
class SBACam(SE3Quat):
    dRdx: numpy.ndarray[float64[3, 3]]
    dRdy: numpy.ndarray[float64[3, 3]]
    dRdz: numpy.ndarray[float64[3, 3]]
    @staticmethod
    def transform_f2w(m: numpy.ndarray[float64[3, 4]], trans: numpy.ndarray[float64[3, 1]], qrot: Quaternion) -> None:
        ...
    @staticmethod
    def transform_w2f(m: numpy.ndarray[float64[3, 4]], trans: numpy.ndarray[float64[3, 1]], qrot: Quaternion) -> None:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, r: Quaternion, t: numpy.ndarray[float64[3, 1]]) -> None:
        ...
    @typing.overload
    def __init__(self, p: SE3Quat) -> None:
        ...
    def set_cam(self, fx: float, fy: float, cx: float, cy: float, tx: float) -> None:
        """
        set up camera matrix
        """
    def set_derivative(self) -> None:
        """
        sets angle derivatives
        """
    def set_dr(self) -> None:
        """
        sets angle derivatives
        """
    def set_projection(self) -> None:
        """
        Set up world-to-image projection matrix (w2i), assumes camera parameters are filled.
        """
    def set_transform(self) -> None:
        """
        set transform from world to cam coords
        """
    def update(self, update: numpy.ndarray[float64[6, 1]]) -> None:
        """
        update from the linear solution defined in se3quat
        """
    @property
    def Kcam(self) -> numpy.ndarray[float64[3, 3]]:
        """
        camera matrix
        """
    @Kcam.setter
    def Kcam(self, arg0: numpy.ndarray[float64[3, 3]]) -> None:
        ...
    @property
    def baseline(self) -> float:
        """
        stereo baseline
        """
    @baseline.setter
    def baseline(self, arg0: float) -> None:
        ...
    @property
    def cam(self) -> numpy.ndarray[float64[3, 3]]:
        """
        camera matrix
        """
    @cam.setter
    def cam(self, arg0: numpy.ndarray[float64[3, 3]]) -> None:
        ...
    @property
    def w2i(self) -> numpy.ndarray[float64[3, 4]]:
        """
        transform from world to image coordinates
        """
    @w2i.setter
    def w2i(self, arg0: numpy.ndarray[float64[3, 4]]) -> None:
        ...
    @property
    def w2n(self) -> numpy.ndarray[float64[3, 4]]:
        """
        transform from world to node coordinates
        """
    @w2n.setter
    def w2n(self, arg0: numpy.ndarray[float64[3, 4]]) -> None:
        ...
class SE2:
    def Isometry2d(self) -> Isometry2d:
        ...
    def __getitem__(self, arg0: int) -> float:
        ...
    def __imul__(self, arg0: SE2) -> SE2:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: Isometry2d) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: numpy.ndarray[float64[3, 1]]) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: float, arg1: float, arg2: float) -> None:
        ...
    @typing.overload
    def __mul__(self, arg0: SE2) -> SE2:
        ...
    @typing.overload
    def __mul__(self, arg0: numpy.ndarray[float64[2, 1]]) -> numpy.ndarray[float64[2, 1]]:
        ...
    def from_vector(self, arg0: numpy.ndarray[float64[3, 1]]) -> None:
        ...
    def inverse(self) -> SE2:
        ...
    def rotation(self) -> Rotation2d:
        ...
    def to_isometry(self) -> Isometry2d:
        ...
    def to_vector(self) -> numpy.ndarray[float64[3, 1]]:
        ...
    def translation(self) -> numpy.ndarray[float64[2, 1]]:
        ...
    def vector(self) -> numpy.ndarray[float64[3, 1]]:
        ...
class SE3Quat:
    @staticmethod
    def exp(update: numpy.ndarray[float64[6, 1]]) -> SE3Quat:
        ...
    def Isometry3d(self) -> Isometry3d:
        ...
    def Quaternion(self) -> Quaternion:
        ...
    def __getitem__(self, i: int) -> float:
        ...
    def __imul__(self, arg0: SE3Quat) -> SE3Quat:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, R: numpy.ndarray[float64[3, 3]], t: numpy.ndarray[float64[3, 1]]) -> None:
        ...
    @typing.overload
    def __init__(self, q: Quaternion, t: numpy.ndarray[float64[3, 1]]) -> None:
        ...
    @typing.overload
    def __init__(self, v: numpy.ndarray[float64[6, 1]]) -> None:
        ...
    @typing.overload
    def __init__(self, v: numpy.ndarray[float64[7, 1]]) -> None:
        ...
    @typing.overload
    def __mul__(self, arg0: SE3Quat) -> SE3Quat:
        ...
    @typing.overload
    def __mul__(self, arg0: numpy.ndarray[float64[3, 1]]) -> numpy.ndarray[float64[3, 1]]:
        ...
    def adj(self) -> numpy.ndarray[float64[6, 6]]:
        ...
    def from_minimal_vector(self, v: numpy.ndarray[float64[6, 1]]) -> None:
        ...
    def from_vector(self, v: numpy.ndarray[float64[7, 1]]) -> None:
        ...
    def inverse(self) -> SE3Quat:
        ...
    def log(self) -> numpy.ndarray[float64[6, 1]]:
        ...
    def map(self, xyz: numpy.ndarray[float64[3, 1]]) -> numpy.ndarray[float64[3, 1]]:
        ...
    def matrix(self) -> numpy.ndarray[float64[4, 4]]:
        ...
    def normalize_rotation(self) -> None:
        ...
    def orientation(self) -> Quaternion:
        ...
    def position(self) -> numpy.ndarray[float64[3, 1]]:
        ...
    def rotation(self) -> Quaternion:
        ...
    def set_rotation(self, q: Quaternion) -> None:
        ...
    def set_translation(self, t: numpy.ndarray[float64[3, 1]]) -> None:
        ...
    def to_homogeneous_matrix(self) -> numpy.ndarray[float64[4, 4]]:
        ...
    def to_minimal_vector(self) -> numpy.ndarray[float64[6, 1]]:
        ...
    def to_vector(self) -> numpy.ndarray[float64[7, 1]]:
        ...
    def translation(self) -> numpy.ndarray[float64[3, 1]]:
        ...
    def vector(self) -> numpy.ndarray[float64[7, 1]]:
        ...
class Sim3:
    def __getitem__(self, arg0: int) -> float:
        ...
    def __imul__(self, arg0: Sim3) -> Sim3:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: Quaternion, arg1: numpy.ndarray[float64[3, 1]], arg2: float) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: numpy.ndarray[float64[3, 3]], arg1: numpy.ndarray[float64[3, 1]], arg2: float) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: numpy.ndarray[float64[7, 1]]) -> None:
        ...
    def __mul__(self, arg0: Sim3) -> Sim3:
        ...
    def inverse(self) -> Sim3:
        ...
    def log(self) -> numpy.ndarray[float64[7, 1]]:
        ...
    def map(self, arg0: numpy.ndarray[float64[3, 1]]) -> numpy.ndarray[float64[3, 1]]:
        ...
    def normalize_rotation(self) -> None:
        ...
    def rotation(self) -> Quaternion:
        ...
    def scale(self) -> float:
        ...
    def translation(self) -> numpy.ndarray[float64[3, 1]]:
        ...
class Solver:
    def additional_vector_space(self) -> int:
        ...
    def b(self) -> float:
        ...
    def levenberg(self) -> bool:
        ...
    def optimizer(self) -> SparseOptimizer:
        ...
    def set_additional_vector_space(self, arg0: int) -> None:
        ...
    def set_levenberg(self, arg0: bool) -> None:
        ...
    def set_optimizer(self, arg0: SparseOptimizer) -> None:
        ...
    def supports_schur(self) -> bool:
        ...
    def vector_size(self) -> int:
        ...
    def x(self) -> float:
        ...
class SparseBlockMatrixX:
    def __init__(self) -> None:
        ...
    def block(self, r: int, c: int) -> numpy.ndarray[float64[m, n]]:
        ...
    def clear(self, dealloc: bool = False) -> None:
        ...
    def cols(self) -> int:
        ...
    def rows(self) -> int:
        ...
class SparseOptimizer(OptimizableGraph):
    def __init__(self) -> None:
        ...
    def active_chi2(self) -> float:
        ...
    def active_edges(self) -> list[OptimizableGraph_Edge]:
        ...
    def active_robust_chi2(self) -> float:
        ...
    def active_vertices(self) -> list[OptimizableGraph_Vertex]:
        ...
    def add_compute_error_action(self, action: ...) -> bool:
        ...
    def algorithm(self) -> ...:
        ...
    def batch_statistics(self) -> list[...]:
        ...
    def clear(self) -> None:
        ...
    def compute_active_errors(self) -> None:
        ...
    def compute_batch_statistics(self) -> bool:
        ...
    @typing.overload
    def compute_initial_guess(self) -> None:
        ...
    @typing.overload
    def compute_initial_guess(self, propagator: ...) -> None:
        ...
    @typing.overload
    def discard_top(self, vlist: list[OptimizableGraph_Vertex]) -> None:
        ...
    @typing.overload
    def discard_top(self) -> None:
        ...
    def find_active_edge(self, e: OptimizableGraph_Edge) -> ...:
        ...
    def find_active_vertex(self, v: OptimizableGraph_Vertex) -> ...:
        ...
    def find_gauge(self) -> OptimizableGraph_Vertex:
        ...
    def force_stop_flag(self) -> bool:
        ...
    def gauge_freedom(self) -> bool:
        ...
    def index_mapping(self) -> list[OptimizableGraph_Vertex]:
        ...
    @typing.overload
    def initialize_optimization(self, eset: set[Edge]) -> bool:
        ...
    @typing.overload
    def initialize_optimization(self, vset: set[Vertex], level: int = 0) -> bool:
        ...
    @typing.overload
    def initialize_optimization(self, level: int = 0) -> bool:
        ...
    def optimize(self, iterations: int, online: bool = False) -> int:
        ...
    @typing.overload
    def pop(self, vlist: list[OptimizableGraph_Vertex]) -> None:
        ...
    @typing.overload
    def pop(self, vlist: set[Vertex]) -> None:
        ...
    @typing.overload
    def pop(self) -> None:
        ...
    @typing.overload
    def push(self, vlist: list[OptimizableGraph_Vertex]) -> None:
        ...
    @typing.overload
    def push(self, vlist: set[Vertex]) -> None:
        ...
    @typing.overload
    def push(self) -> None:
        ...
    def remove_compute_error_action(self, action: ...) -> bool:
        ...
    def remove_vertex(self, v: Vertex, detach: bool = False) -> bool:
        ...
    @typing.overload
    def set_algorithm(self, arg0: ...) -> None:
        ...
    @typing.overload
    def set_algorithm(self, arg0: ...) -> None:
        ...
    @typing.overload
    def set_algorithm(self, arg0: ...) -> None:
        ...
    @typing.overload
    def set_algorithm(self, arg0: ...) -> None:
        ...
    @typing.overload
    def set_algorithm(self, arg0: ...) -> None:
        ...
    def set_compute_batch_statistics(self, arg0: bool) -> None:
        ...
    def set_force_stop_flag(self, flag: bool) -> None:
        ...
    def set_to_origin(self) -> None:
        ...
    def set_verbose(self, verbose: bool) -> None:
        ...
    def solver(self) -> ...:
        ...
    def terminate(self) -> bool:
        ...
    def update(self, update: float) -> None:
        ...
    def update_initialization(self, vset: set[Vertex], eset: set[Edge]) -> bool:
        ...
    def verbose(self) -> bool:
        ...
class SparseOptimizerTerminateAction(HyperGraphAction):
    def __call__(self, arg0: HyperGraph, arg1: ...) -> HyperGraphAction:
        ...
    def __init__(self) -> None:
        ...
    def gain_threshold(self) -> float:
        ...
    def max_iterations(self) -> int:
        ...
    def set_gain_threshold(self, arg0: float) -> None:
        ...
    def set_max_iterations(self, arg0: int) -> None:
        ...
class TransformTraits:
    Affine: typing.ClassVar[TransformTraits]  # value = TransformTraits.Affine
    AffineCompact: typing.ClassVar[TransformTraits]  # value = TransformTraits.AffineCompact
    Isometry: typing.ClassVar[TransformTraits]  # value = TransformTraits.Isometry
    Projective: typing.ClassVar[TransformTraits]  # value = TransformTraits.Projective
    __members__: typing.ClassVar[dict[str, TransformTraits]]  # value = {'Isometry': TransformTraits.Isometry, 'Affine': TransformTraits.Affine, 'AffineCompact': TransformTraits.AffineCompact, 'Projective': TransformTraits.Projective}
    @typing.overload
    def __eq__(self, arg0: TransformTraits) -> bool:
        ...
    @typing.overload
    def __eq__(self, arg0: int) -> bool:
        ...
    def __getstate__(self) -> tuple:
        ...
    def __hash__(self) -> int:
        ...
    def __init__(self, arg0: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    @typing.overload
    def __ne__(self, arg0: TransformTraits) -> bool:
        ...
    @typing.overload
    def __ne__(self, arg0: int) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
class UniformCostFunction(HyperDijkstra.HyperDijkstraCostFunction):
    def __call__(self, edge: Edge, from: Vertex, to: Vertex) -> float:
        ...
class VelocityMeasurement:
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, vl: float, vr: float, dt: float) -> None:
        ...
    def dt(self) -> float:
        ...
    def measurement(self) -> numpy.ndarray[float64[2, 1]]:
        ...
    def set_dt(self, arg0: float) -> None:
        ...
    def set_vl(self, arg0: float) -> None:
        ...
    def set_vr(self, arg0: float) -> None:
        ...
    def vl(self) -> float:
        ...
    def vr(self) -> float:
        ...
class VertexCam(BaseVertex_6_SBACam):
    def __init__(self) -> None:
        ...
    def estimate_dimension(self) -> int:
        ...
    def get_estimate_data(self, arg0: float) -> bool:
        ...
    def get_minimal_estimate_data(self, arg0: float) -> bool:
        ...
    def minimal_estimate_dimension(self) -> int:
        ...
    def oplus_impl(self, arg0: float) -> None:
        ...
    def set_estimate(self, arg0: ...) -> None:
        ...
    def set_estimate_data_impl(self, arg0: float) -> bool:
        ...
    def set_minimal_estimate_data_impl(self, arg0: float) -> bool:
        ...
    def set_to_origin_impl(self) -> None:
        ...
class VertexIntrinsics(BaseVertex_4_Vector5d):
    def __init__(self) -> None:
        ...
    def oplus_impl(self, arg0: float) -> None:
        ...
    def set_to_origin_impl(self) -> None:
        ...
class VertexOdomDifferentialParams(BaseVertex_3_Vector3D):
    def __init__(self) -> None:
        ...
    def oplus_impl(self, arg0: float) -> None:
        ...
    def set_to_origin_impl(self) -> None:
        ...
class VertexPointXY(BaseVertex_2_Vector2D):
    def __init__(self) -> None:
        ...
    def estimate_dimension(self) -> int:
        ...
    def get_estimate_data(self, arg0: float) -> bool:
        ...
    def get_minimal_estimate_data(self, arg0: float) -> bool:
        ...
    def minimal_estimate_dimension(self) -> int:
        ...
    def oplus_impl(self, arg0: float) -> None:
        ...
    def set_estimate_data_impl(self, arg0: float) -> bool:
        ...
    def set_minimal_estimate_data_impl(self, arg0: float) -> bool:
        ...
    def set_to_origin_impl(self) -> None:
        ...
class VertexPointXYZ(BaseVertex_3_Vector3D):
    def __init__(self) -> None:
        ...
    def estimate_dimension(self) -> int:
        ...
    def get_estimate_data(self, arg0: float) -> bool:
        ...
    def get_minimal_estimate_data(self, arg0: float) -> bool:
        ...
    def minimal_estimate_dimension(self) -> int:
        ...
    def oplus_impl(self, arg0: float) -> None:
        ...
    def set_estimate_data_impl(self, arg0: float) -> bool:
        ...
    def set_minimal_estimate_data_impl(self, arg0: float) -> bool:
        ...
    def set_to_origin_impl(self) -> None:
        ...
class VertexSBAPointXYZ(BaseVertex_3_Vector3D):
    def __init__(self) -> None:
        ...
    def oplus_impl(self, arg0: float) -> None:
        ...
    def set_to_origin_impl(self) -> None:
        ...
class VertexSCam(VertexSE3):
    Kcam: typing.ClassVar[numpy.ndarray]  # value = array([[0., 0., 0.],...
    baseline: typing.ClassVar[float] = 0.0
    dRidx: typing.ClassVar[numpy.ndarray]  # value = array([[ 0.,  0.,  0.],...
    dRidy: typing.ClassVar[numpy.ndarray]  # value = array([[ 0.,  0., -2.],...
    dRidz: typing.ClassVar[numpy.ndarray]  # value = array([[ 0.,  2.,  0.],...
    dRdx: numpy.ndarray[float64[3, 3]]
    dRdy: numpy.ndarray[float64[3, 3]]
    dRdz: numpy.ndarray[float64[3, 3]]
    w2i: numpy.ndarray[float64[3, 4]]
    w2n: numpy.ndarray[float64[3, 4]]
    @staticmethod
    def set_cam(fx: float, fy: float, cx: float, cy: float, tx: float) -> None:
        """
        set up camera matrix
        """
    @staticmethod
    def transform_f2w(m: numpy.ndarray[float64[3, 4]], trans: numpy.ndarray[float64[3, 1]], qrot: Quaternion) -> None:
        ...
    @staticmethod
    def transform_w2f(m: numpy.ndarray[float64[3, 4]], trans: numpy.ndarray[float64[3, 1]], qrot: Quaternion) -> None:
        ...
    def __init__(self) -> None:
        ...
    def map_point(self, arg0: numpy.ndarray[float64[3, 1]]) -> numpy.ndarray[float64[3, 1]]:
        ...
    def oplus_impl(self, arg0: float) -> None:
        ...
    def set_all(self) -> None:
        """
        set all aux transforms
        """
    def set_derivative(self) -> None:
        """
        sets angle derivatives
        """
    def set_dr(self) -> None:
        """
        sets angle derivatives
        """
    def set_projection(self) -> None:
        """
        Set up world-to-image projection matrix (w2i), assumes camera parameters are filled.
        """
    def set_transform(self) -> None:
        """
        set transform from world to cam coords
        """
class VertexSE2(BaseVertex_3_SE2):
    def __init__(self) -> None:
        ...
    def estimate_dimension(self) -> int:
        ...
    def get_estimate_data(self, arg0: float) -> bool:
        ...
    def get_minimal_estimate_data(self, arg0: float) -> bool:
        ...
    def minimal_estimate_dimension(self) -> int:
        ...
    def oplus_impl(self, arg0: float) -> None:
        ...
    def set_estimate_data_impl(self, arg0: float) -> bool:
        ...
    def set_minimal_estimate_data_impl(self, arg0: float) -> bool:
        ...
    def set_to_origin_impl(self) -> None:
        ...
class VertexSE3(BaseVertex_6_Isometry3D):
    def __init__(self) -> None:
        ...
    def estimate_dimension(self) -> int:
        ...
    def get_estimate_data(self, arg0: float) -> bool:
        ...
    def get_minimal_estimate_data(self, arg0: float) -> bool:
        ...
    def minimal_estimate_dimension(self) -> int:
        ...
    def oplus_impl(self, arg0: float) -> None:
        ...
    def set_estimate_data_impl(self, arg0: float) -> bool:
        ...
    def set_minimal_estimate_data_impl(self, arg0: float) -> bool:
        ...
    def set_to_origin_impl(self) -> None:
        ...
class VertexSE3Expmap(BaseVertex_6_SE3Quat):
    def __init__(self) -> None:
        ...
    def oplus_impl(self, arg0: float) -> None:
        ...
    def set_to_origin_impl(self) -> None:
        ...
class VertexSim3Expmap(BaseVertex_7_Sim3):
    def __init__(self) -> None:
        ...
    def cam_map1(self, arg0: numpy.ndarray[float64[2, 1]]) -> numpy.ndarray[float64[2, 1]]:
        ...
    def cam_map2(self, arg0: numpy.ndarray[float64[2, 1]]) -> numpy.ndarray[float64[2, 1]]:
        ...
    def oplus_impl(self, arg0: float) -> None:
        ...
    def set_to_origin_impl(self) -> None:
        ...
Affine: TransformTraits  # value = TransformTraits.Affine
AffineCompact: TransformTraits  # value = TransformTraits.AffineCompact
Isometry: TransformTraits  # value = TransformTraits.Isometry
Projective: TransformTraits  # value = TransformTraits.Projective
